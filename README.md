# PriFi doc

In this branch I try to update the project's documentation. Below is
a list of functions/types that I do not know how to document:

```
prifi_lib/crypto/schnorr.go:
	SchnorrVerify

prifi_lib/dcnet/test.go:
	all

prifi_lib/scheduler.deprecated/scheduler.go (not sure if needed):
	all
```

# Tentative "user guide"

## The PriFi protocol for anonymous communication

The PriFi protocols has three types of participants:

- The trustees
- The relay
- The clients

The clients send their messages through the relay. The protocol guarantees
that it is not possible for anyone except the sender to determine which of
the clients sent a message to the relay, provided at least one trustee is
honest (we do not have to know which one it is).

### Protocol details

The protocol is based on
 [DC-nets](https://en.wikipedia.org/wiki/Dining_cryptographers_problem)
 to provide anonymity. This section describes the protocol in details.

[//]: # (This is the Algorithm 1 in the WPES paper)

#### Notation

Let `C1,...,Cn` denote the clients, `R` denote the relay, `T1,...,Tm` denote the trustees
and `l` denote the bit-length of ciphertexts sent by clients and servers to the relay
in each slot. All participants have a long term public/private key pair.

#### Setup

1. `R` authenticates each client using it's public key.
1. For `i ∈ [n]` and `j ∈ [m]`, each client `Ci` runs a key exchange protocol with each
trustee `Tj` to agree on a shared secret `rij ∈ {0, 1}^l`.

#### Scheduling

1. Each client `Ci` generates an ephemeral pair of public/private
keys `(Zi , zi)`, sends `Zi` to `R`, and sets the time slot number
`t ← 0`.
1. `R` collects all `Zi`’s as a sequence `A` and sends it to `T1`.
1. The trustees take turn and shuffle `A` using a verifiable shuffle, each sending
its result and proof to other trustees via `R`.
1. Each trustee verifies the shuffles, signs them with its private
key, and sends the signature to all clients for verification.

#### Anonymization

1. Each trustee `Tj` picks an `l`-bit pseudorandom pad `Pij` for
each client `Ci` using a PRG seeded with `rij` . The server
then computes its ciphertext
```
Sj ← P1j ⊕ ... ⊕ Pnj
```
and sends it to R.
1. Each client `Ci` performs the following steps:
    1. Generate an `l`-bit pseudorandom pad `Pij` for each server
    `Sj` using a PRG seeded with `rij`.
    1. Let `π` denote the permutation generated by the scheduling phase,
    and `Xi` denote `Ci`’s next `l` bits of data.
    Compute and send a ciphertext `Ki` to `R` such that if
    `t mod n = π(i)`, then
    ```
    Ki ← Xi ⊕ Pi1 ⊕ ... ⊕ Pim
    ```
    Otherwise,
    ```
    Ki ← Pi1 ⊕ ... ⊕ Pim
    ```
    1. `t ← t + 1`
1. `R` collects the ciphertexts `S1 , ..., Sm` from the servers and
`K1 , ..., Kn` from the clients and computes
```
y ← s 1 ⊕ ... ⊕ s m ⊕ c 1 ⊕ ... ⊕ c n
```
It then sends y to the corresponding Internet address.
1. Upon receiving a response from the Internet, `R` broadcasts
the message to all clients.
1. If any client or server disconnects, `R` broadcasts a Reschedule
request to all clients and servers.
1. If any client or server receives a Reschedule request from `R`,
the receiver repeats the Scheduling phase.

### The Go implementation

This section describes how and where are the above concepts implemented.


## Running PriFi as a simulation

Currently the PriFi code can be run through a simulation. To run it first
make sure that:

- `$GOPATH/src/github.com/dedis/cothority` is on branch `prifi` and pulled to
the latest version.
- `$GOPATH/src/github.com/dedis/crypto` is on branch `master` and pulled to
the latest version.
- `$GOPATH/src/github.com/lbarman/prifi_dev` is on branch `PriFi-SDA` and
pulled to the latest version and that you are in this directory.

We can now run the simulation:

```
./run-prifi-via-simulation.sh
```

It is possible to browse through PriFi using the SOCKS5 integration. To use
it launch the SOCKS5 server:

```
go run socks/run-server.go
```

and configure your browser to use a SOCKS5 proxy on `localhost` on port `6789`.

### Simulation parameters

The configuration for the simulation is located in the Cothority repository,
in the file `simul/runfiles/prifi_simple.toml`. This file contains the following
parameters:

- `Servers (int)`: Number of logical cothority entities. There is a trick here,
when using udp in local (with channels) we should specify ONE server so
all entities are run on the same name space, and share the channels.
Otherwise, this parameter does not have much effect.

- `Bf (int)`: Branching factor of cothority's communication tree. Here we
want a flat tree (1 layer with relay, all nodes directly below).
- `Rounds (int)`: Numers of round to simulate (not PriFi).
- `CloseWait (int)`: Wait that much (in milliseconds ?) before killing a
cothority protocol and going to next simulation round.
- `DataOutputEnbaled (bool)`: Enables the link from and to the socks proxy.
- `NTrustees (int)`: Number of trustees.
- `CellSizeUp (int)`: Size of upstream data sent in one PriFi round (?)
- `CellSizeDown (int)`: Size of upstream data sent in one PriFi round (?)
- `RelayWindowSize (int)`: Number of ciphers from each trustee to buffer
- `RelayUseDummyDataDown (bool)`: When true, the relay always send
CellSizeDown bits down. When false, it may send only 1 bit.
- `RelayReportingLimit (int)`: Unused, was for the statistics.
- `UseUDP (bool)`: Enable or disable UDP broadcast for downstream data (?)
- `DoLatencyTests (bool)`: Enable or disable latency tests.
- `ReportingLimit (int)`: PriFi shuts down after this number of rounds if
not equal to `-1`.
- `Hosts (int)`: When NOT in localhost (but in DeterLab), number of physical
machines to deploy cothority (and PriFi) on.

### Reference configuration file

The following configuration should allow you to run the simulation and browse
through the SOCKS5 proxy without problems (you can copy it in
`simul/runfiles/prifi_simple.toml`):

```
Simulation = "PriFi"
Servers=5
Bf = 100
Rounds = 10
CloseWait = 6000
DataOutputEnable = true
NTrustees = 2
CellSizeUp = 1000
CellSizeDown = 10000
RelayWindowSize = 10
RelayUseDummyDataDown = false
RelayReportingLimit = -10
UseUDP = false
DoLatencyTests = false
ReportingLimit = 10

Hosts
5
```
