<!DOCTYPE html>

<html>
<head>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type">
<meta content="width=device-width, initial-scale=1" name="viewport">
<meta content="#375EAB" name="theme-color">
<title>proof - The PriFi Project</title>
<link href="../../../../.goduckstyle/style.css" rel="stylesheet" type="text/css">
<link href="../../../../.goduckstyle/jquery.treeview.css" rel="stylesheet">
<script type="text/javascript">window.initFuncs = [];</script>
</link></link></meta></meta></meta></head>
<body>
<div id="lowframe" style="position: fixed; bottom: 0; left: 0; height: 0; width: 100%; border-top: thin solid grey; background-color: white; overflow: auto;">
...
</div><!-- #lowframe -->
<div class="wide" id="topbar"><div class="container">
<div class="top-heading" id="heading-wide">The PriFi Project</div>
<div class="top-heading" id="heading-narrow"><a href="/">Go</a></div>
<a href="#" id="menu-button"><span id="menu-button-arrow">▽</span></a>
<form action="/search" method="GET">
<div id="menu">





</div>
</form>
</div></div>
<div class="wide" id="page">
<div class="container">
<h1>Package proof</h1>
<div id="nav"></div>
<!--
	Copyright 2009 The Go Authors. All rights reserved.
	Use of this source code is governed by a BSD-style
	license that can be found in the LICENSE file.
-->
<!--
	Note: Static (i.e., not template-generated) href and id
	attributes start with "pkg-" to make it impossible for
	them to conflict with generated attributes (some of which
	correspond to Go identifiers).
-->
<script type="text/javascript">
	document.ANALYSIS_DATA = null;
	document.CALLGRAPH = null;
	</script>
<div id="short-nav">
<dl>
<dd><code>import "github.com/dedis/crypto/proof"</code></dd>
</dl>
<dl>
<dd><a class="overviewLink" href="#pkg-overview">Overview</a></dd>
<dd><a class="indexLink" href="#pkg-index">Index</a></dd>
<dd><a class="examplesLink" href="#pkg-examples">Examples</a></dd>
</dl>
</div>
<!-- The package's Name is printed as title by the top-level template -->
<div class="toggleVisible" id="pkg-overview">
<div class="collapsed">
<h2 class="toggleButton" title="Click to show Overview section">Overview ▹</h2>
</div>
<div class="expanded">
<h2 class="toggleButton" title="Click to hide Overview section">Overview ▾</h2>
<p>
Package proof implements generic support for Sigma-protocols
and discrete logarithm proofs in the Camenisch/Stadler framework.
For the cryptographic foundations of this framework see
"Proof Systems for General Statements about Discrete Logarithms" at
<a href="ftp://ftp.inf.ethz.ch/pub/crypto/publications/CamSta97b.pdfindex.html">ftp://ftp.inf.ethz.ch/pub/crypto/publications/CamSta97b.pdf</a>.
</p>
</div>
</div>
<div class="toggleVisible" id="pkg-index">
<div class="collapsed">
<h2 class="toggleButton" title="Click to show Index section">Index ▹</h2>
</div>
<div class="expanded">
<h2 class="toggleButton" title="Click to hide Index section">Index ▾</h2>
<!-- Table of contents for API; must be named manual-nav to turn off auto nav. -->
<div id="manual-nav">
<dl>
<dd><a href="#DeniableProver">func DeniableProver(suite abstract.Suite, self int, prover Prover, verifiers []Verifier) clique.Protocol</a></dd>
<dd><a href="#HashProve">func HashProve(suite abstract.Suite, protocolName string, random abstract.Cipher, prover Prover) ([]byte, error)</a></dd>
<dd><a href="#HashVerify">func HashVerify(suite abstract.Suite, protocolName string, verifier Verifier, proof []byte) error</a></dd>
<dd><a href="#Predicate">type Predicate</a></dd>
<dd>    <a href="#And">func And(sub ...Predicate) Predicate</a></dd>
<dd>    <a href="#Or">func Or(sub ...Predicate) Predicate</a></dd>
<dd>    <a href="#Rep">func Rep(P string, SB ...string) Predicate</a></dd>
<dd><a href="#Prover">type Prover</a></dd>
<dd><a href="#ProverContext">type ProverContext</a></dd>
<dd><a href="#Verifier">type Verifier</a></dd>
<dd><a href="#VerifierContext">type VerifierContext</a></dd>
</dl>
</div><!-- #manual-nav -->
<div id="pkg-examples">
<h4>Examples</h4>
<dl>
<dd><a class="exampleLink" href="#example_And_1">And (1)</a></dd>
<dd><a class="exampleLink" href="#example_And_2">And (2)</a></dd>
<dd><a class="exampleLink" href="#example_HashProve_1">HashProve (1)</a></dd>
<dd><a class="exampleLink" href="#example_HashProve_2">HashProve (2)</a></dd>
<dd><a class="exampleLink" href="#example_Or_1">Or (1)</a></dd>
<dd><a class="exampleLink" href="#example_Or_2">Or (2)</a></dd>
<dd><a class="exampleLink" href="#example_Rep_1">Rep (1)</a></dd>
<dd><a class="exampleLink" href="#example_Rep_2">Rep (2)</a></dd>
<dd><a class="exampleLink" href="#example_Rep_3">Rep (3)</a></dd>
</dl>
</div>
<h4>Package files</h4>
<p>
<span style="font-size:90%">
<a href="/src/github.com/dedis/crypto/proof/context.go">context.go</a>
<a href="/src/github.com/dedis/crypto/proof/deniable.go">deniable.go</a>
<a href="/src/github.com/dedis/crypto/proof/hash.go">hash.go</a>
<a href="/src/github.com/dedis/crypto/proof/proof.go">proof.go</a>
</span>
</p>
</div><!-- .expanded -->
</div><!-- #pkg-index -->
<div class="toggle" id="pkg-callgraph" style="display: none">
<div class="collapsed">
<h2 class="toggleButton" title="Click to show Internal Call Graph section">Internal call graph ▹</h2>
</div> <!-- .expanded -->
<div class="expanded">
<h2 class="toggleButton" title="Click to hide Internal Call Graph section">Internal call graph ▾</h2>
<p>
			  In the call graph viewer below, each node
			  is a function belonging to this package
			  and its children are the functions it
			  calls—perhaps dynamically.
			</p>
<p>
			  The root nodes are the entry points of the
			  package: functions that may be called from
			  outside the package.
			  There may be non-exported or anonymous
			  functions among them if they are called
			  dynamically from another package.
			</p>
<p>
			  Click a node to visit that function's source code.
			  From there you can visit its callers by
			  clicking its declaring <code>func</code>
			  token.
			</p>
<p>
			  Functions may be omitted if they were
			  determined to be unreachable in the
			  particular programs or tests that were
			  analyzed.
			</p>
<!-- Zero means show all package entry points. -->
<ul class="treeview" id="callgraph-0" style="margin-left: 0.5in"></ul>
</div>
</div> <!-- #pkg-callgraph -->
<h2 id="DeniableProver">func <a href="/src/github.com/dedis/crypto/proof/deniable.go?s=510:615#L7">DeniableProver</a>
<a class="permalink" href="#DeniableProver">¶</a>
</h2>
<pre>func DeniableProver(suite <a href="../../../../github.com/dedis/crypto/abstract/index.html">abstract</a>.<a href="../../../../github.com/dedis/crypto/abstract/index.html#Suite">Suite</a>, self <a href="https://golang.org/pkg/builtin/#int">int</a>, prover <a href="#Prover">Prover</a>,
    verifiers []<a href="#Verifier">Verifier</a>) <a href="../../../../github.com/dedis/crypto/clique/index.html">clique</a>.<a href="../../../../github.com/dedis/crypto/clique/index.html#Protocol">Protocol</a></pre>
<p>
Create a clique.Protocol implementing an interactive Sigma-protocol
to prove a particular statement to the other participants.
Optionally the clique.Protocol participant can also verify
the Sigma-protocol proofs of any or all of the other participants.
Different participants may produce different proofs of varying sizes,
and may even consist of different numbers of steps.
</p>
<h2 id="HashProve">func <a href="/src/github.com/dedis/crypto/proof/hash.go?s=3277:3390#L109">HashProve</a>
<a class="permalink" href="#HashProve">¶</a>
</h2>
<pre>func HashProve(suite <a href="../../../../github.com/dedis/crypto/abstract/index.html">abstract</a>.<a href="../../../../github.com/dedis/crypto/abstract/index.html#Suite">Suite</a>, protocolName <a href="https://golang.org/pkg/builtin/#string">string</a>,
    random <a href="../../../../github.com/dedis/crypto/abstract/index.html">abstract</a>.<a href="../../../../github.com/dedis/crypto/abstract/index.html#Cipher">Cipher</a>, prover <a href="#Prover">Prover</a>) ([]<a href="https://golang.org/pkg/builtin/#byte">byte</a>, <a href="https://golang.org/pkg/builtin/#error">error</a>)</pre>
<p>
HashProve runs a given Sigma-protocol prover with a ProverContext
that produces a non-interactive proof via the Fiat-Shamir heuristic.
Returns a byte-slice containing the noninteractive proof on success,
or an error in the case of failure.
</p>
<p>
The optional protocolName is fed into the hash function used in the proof,
so that a proof generated for a particular protocolName
will verify successfully only if the verifier uses the same protocolName.
</p>
<p>
The caller must provide a source of random entropy for the proof;
this can be random.Stream to use fresh random bits,
or a pseudorandom stream based on a secret seed
to create deterministically reproducible proofs.
</p>
<div class="toggle" id="example_HashProve_1">
<div class="collapsed">
<p class="exampleHeading toggleButton">▹ <span class="text">Example (1)</span></p>
</div>
<div class="expanded">
<p class="exampleHeading toggleButton">▾ <span class="text">Example (1)</span></p>
<p>This example shows how to build classic ElGamal-style digital signatures
using the Camenisch/Stadler proof framework and HashProver.
</p>
<p>Code:</p>
<pre class="code"><span class="comment">// Crypto setup</span>
suite := nist.NewAES128SHA256P256()
rand := suite.Cipher([]byte("example"))
B := suite.Point().Base() <span class="comment">// standard base point</span>

<span class="comment">// Create a public/private keypair (X,x)</span>
x := suite.Scalar().Pick(rand) <span class="comment">// create a private key x</span>
X := suite.Point().Mul(nil, x) <span class="comment">// corresponding public key X</span>

<span class="comment">// Generate a proof that we know the discrete logarithm of X.</span>
M := "Hello World!" <span class="comment">// message we want to sign</span>
rep := Rep("X", "x", "B")
sec := map[string]abstract.Scalar{"x": x}
pub := map[string]abstract.Point{"B": B, "X": X}
prover := rep.Prover(suite, sec, pub, nil)
proof, _ := HashProve(suite, M, rand, prover)
fmt.Print("Signature:\n" + hex.Dump(proof))

<span class="comment">// Verify the signature against the correct message M.</span>
verifier := rep.Verifier(suite, pub)
err := HashVerify(suite, M, verifier, proof)
if err != nil {
    panic("signature failed to verify!")
}
fmt.Println("Signature verified against correct message M.")

<span class="comment">// Now verify the signature against the WRONG message.</span>
BAD := "Goodbye World!"
verifier = rep.Verifier(suite, pub)
err = HashVerify(suite, BAD, verifier, proof)
fmt.Println("Signature verify against wrong message: " + err.Error())

<span class="comment"></span></pre>
<p>Output:</p>
<pre class="output">Signature:
00000000  04 23 62 b1 f9 cb f4 a2  6d 7f 3e 69 cb b6 77 ab  |.#b.....m.&gt;i..w.|
00000010  90 fc 7c db a0 c6 e8 12  f2 0a d4 40 a4 b6 c4 de  |..|........@....|
00000020  9e e8 61 88 5e 50 fd 03  a9 ff 9c a3 c4 29 f7 18  |..a.^P.......)..|
00000030  49 ad 31 0e f9 17 15 1e  3b 8d 0e 2f b2 c4 28 32  |I.1.....;../..(2|
00000040  4a 5c 64 ca 04 eb 33 db  a9 75 9b 01 6b 12 01 ae  |J\d...3..u..k...|
00000050  4e de 7c 6b 53 85 f8 a5  76 ba eb 7e 2e 61 2c a5  |N.|kS...v..~.a,.|
00000060  e8                                                |.|
Signature verified against correct message M.
Signature verify against wrong message: invalid proof: commit mismatch
</pre>
</div>
</div>
<div class="toggle" id="example_HashProve_2">
<div class="collapsed">
<p class="exampleHeading toggleButton">▹ <span class="text">Example (2)</span></p>
</div>
<div class="expanded">
<p class="exampleHeading toggleButton">▾ <span class="text">Example (2)</span></p>
<p>This example implements Linkable Ring Signatures (LRS) generically
using the Camenisch/Stadler proof framework and HashProver.

A ring signature proves that the signer owns one of a list of public keys,
without revealing anything about which public key the signer actually owns.
A linkable ring signature (LRS) is the same but includes a linkage tag,
which the signer proves to correspond 1-to-1 with the signer's key,
but whose relationship to the private key remains secret
from anyone who does not hold the private key.
A key-holder who signs multiple messages in the same public "linkage scope"
will be forced to use the same linkage tag in each such signature,
enabling others to tell whether two signatures in a given scope
were produced by the same or different signers.

This scheme is conceptually similar to that of Liu/Wei/Wong in
"Linkable and Anonymous Signature for Ad Hoc Groups".
This example implementation is less space-efficient, however,
because it uses the generic HashProver for Fiat-Shamir noninteractivity
instead of Liu/Wei/Wong's customized hash-ring structure.
</p>
<p>Code:</p>
<pre class="code"><span class="comment">// Crypto setup</span>
suite := nist.NewAES128SHA256P256()
rand := suite.Cipher([]byte("example"))
B := suite.Point().Base() <span class="comment">// standard base point</span>

<span class="comment">// Create an anonymity ring of random "public keys"</span>
X := make([]abstract.Point, 3)
for i := range X { <span class="comment">// pick random points</span>
    X[i], _ = suite.Point().Pick(nil, rand)
}

<span class="comment">// Make just one of them an actual public/private keypair (X[mine],x)</span>
mine := 2                           <span class="comment">// only the signer knows this</span>
x := suite.Scalar().Pick(rand)      <span class="comment">// create a private key x</span>
X[mine] = suite.Point().Mul(nil, x) <span class="comment">// corresponding public key X</span>

<span class="comment">// Produce the correct linkage tag for the signature,</span>
<span class="comment">// as a pseudorandom base point multiplied by our private key.</span>
linkScope := []byte("The Linkage Scope")
linkHash := suite.Cipher(linkScope)
linkBase, _ := suite.Point().Pick(nil, linkHash)
linkTag := suite.Point().Mul(linkBase, x)

<span class="comment">// Generate the proof predicate: an OR branch for each public key.</span>
sec := map[string]abstract.Scalar{"x": x}
pub := map[string]abstract.Point{"B": B, "BT": linkBase, "T": linkTag}
preds := make([]Predicate, len(X))
for i := range X {
    name := fmt.Sprintf("X[%d]", i) <span class="comment">// "X[0]","X[1]",...</span>
    pub[name] = X[i]                <span class="comment">// public point value</span>

    <span class="comment">// Predicate indicates knowledge of the private key for X[i]</span>
    <span class="comment">// and correspondence of the key with the linkage tag</span>
    preds[i] = And(Rep(name, "x", "B"), Rep("T", "x", "BT"))
}
pred := Or(preds...) <span class="comment">// make a big Or predicate</span>
fmt.Printf("Linkable Ring Signature Predicate:\n\t%s\n", pred.String())

<span class="comment">// The prover needs to know which Or branch (mine) is actually true.</span>
choice := make(map[Predicate]int)
choice[pred] = mine

<span class="comment">// Generate the signature</span>
M := "Hello World!" <span class="comment">// message we want to sign</span>
prover := pred.Prover(suite, sec, pub, choice)
proof, _ := HashProve(suite, M, rand, prover)
fmt.Print("Linkable Ring Signature:\n" + hex.Dump(proof))

<span class="comment">// Verify the signature</span>
verifier := pred.Verifier(suite, pub)
err := HashVerify(suite, M, verifier, proof)
if err != nil {
    panic("signature failed to verify!")
}
fmt.Println("Linkable Ring Signature verified.")

<span class="comment"></span></pre>
<p>Output:</p>
<pre class="output">Linkable Ring Signature Predicate:
	(X[0]=x*B &amp;&amp; T=x*BT) || (X[1]=x*B &amp;&amp; T=x*BT) || (X[2]=x*B &amp;&amp; T=x*BT)
Linkable Ring Signature:
00000000  04 56 81 70 79 e2 f6 ea  5b 06 a5 f5 72 5d f5 e0  |.V.py...[...r]..|
00000010  b6 e6 d3 90 52 af 84 7a  b1 78 a9 03 f3 29 1e a2  |....R..z.x...)..|
00000020  1a 59 50 28 9b 6c d7 ca  72 25 83 67 2d fe f7 f0  |.YP(.l..r%.g-...|
00000030  96 e9 ae 9b 9e a0 eb 76  7f 74 6d bc 42 18 a1 d1  |.......v.tm.B...|
00000040  0e 04 d8 28 10 ae b9 25  87 e9 a1 c4 fa 1b ff 88  |...(...%........|
00000050  96 bd da 4a 7f 58 c9 b5  57 57 7f 8b ee 4e 00 40  |...J.X..WW...N.@|
00000060  fa 2c 6a 49 74 41 9a c6  7d ac 78 fa 58 35 84 40  |.,jItA..}.x.X5.@|
00000070  2a 95 62 8c 05 5c 75 57  4e 74 22 a9 5f 78 48 22  |*.b..\uWNt"._xH"|
00000080  1f 97 04 f7 a8 0d ec 81  39 31 fb 8b 8b 12 09 74  |........91.....t|
00000090  46 9f 46 22 e9 69 cc 25  c5 b6 23 5b 2a 4b 3d 4c  |F.F".i.%..#[*K=L|
000000a0  10 f7 73 e0 22 00 f3 99  28 be ad 07 8c ef 44 a6  |..s."...(.....D.|
000000b0  d8 e0 ee 5e 04 c7 d1 60  b4 f0 8d e3 bd b3 31 8e  |...^...`......1.|
000000c0  19 9a 56 04 9f da 0c 05  3f 04 42 e4 d3 e3 78 00  |..V.....?.B...x.|
000000d0  d8 bc 31 c2 00 fd 29 64  63 65 e5 9a 1c 5f b4 01  |..1...)dce..._..|
000000e0  ca 14 c5 48 bc 73 60 31  9e 18 7d 93 c8 69 cc c9  |...H.s`1..}..i..|
000000f0  a4 c7 72 e0 c2 a8 2e 47  f5 fa e8 1f de c0 14 52  |..r....G.......R|
00000100  9f 7a a7 5b 04 2e b4 bb  d5 a1 8a 80 4e 48 1e 07  |.z.[........NH..|
00000110  20 e0 f8 9a 6a 9c 5a b7  8b 08 9c 6d c7 0e 9c 9f  | ...j.Z....m....|
00000120  3f 6b d3 34 7e 50 91 6b  87 03 d5 54 b6 87 f1 2d  |?k.4~P.k...T...-|
00000130  4c d6 9e df fe 1b 7f 07  be 5e d5 88 7f 2b b0 58  |L........^...+.X|
00000140  e2 12 62 15 00 04 d8 45  d5 c4 91 77 0c 74 5c 54  |..b....E...w.t\T|
00000150  89 e9 cd 75 9b c5 20 67  26 d8 e4 e8 ed 68 96 51  |...u.. g&amp;....h.Q|
00000160  6f 39 e5 62 e5 c5 24 15  5e 45 69 91 c0 83 2c 6b  |o9.b..$.^Ei...,k|
00000170  33 fe af 75 c2 23 ca 88  b2 a8 c8 be f2 4f f0 e9  |3..u.#.......O..|
00000180  65 af e6 b1 7e e6 eb 40  46 de 61 2f 08 8d 9a 04  |e...~..@F.a/....|
00000190  09 d7 a1 62 83 48 e3 cc  09 af 64 26 df df da d6  |...b.H....d&amp;....|
000001a0  51 62 5d e6 2b 56 b2 b5  3a e1 c8 8c f7 29 8a 13  |Qb].+V..:....)..|
000001b0  75 59 98 ea ce f4 6d d5  d0 62 85 51 8e fe d9 4a  |uY....m..b.Q...J|
000001c0  02 1f 35 03 33 d3 0e 4e  6b b8 fc f9 c9 92 4d e9  |..5.3..Nk.....M.|
000001d0  c3 1c 35 ec 19 43 7c 25  1b b4 70 09 30 08 e3 a1  |..5..C|%..p.0...|
000001e0  e1 42 ed 92 0d 82 63 d3  5a 0e 97 78 e6 74 ce a0  |.B....c.Z..x.t..|
000001f0  24 34 c1 66 7d af 32 9e  59 22 f2 9a 67 3c ea e5  |$4.f}.2.Y"..g&lt;..|
00000200  4f 54 6d 3e 07 f1 1e 6d  18 7f 8b 95 e3 c4 b9 33  |OTm&gt;...m.......3|
00000210  ad 94 69 b5 b4 13 b8 51  2f 24 a7 98 e4 06 f4 b2  |..i....Q/$......|
00000220  f3 ee e8 73 de 78 d1 ab  ff 11 e3 6e df 3d a8 b5  |...s.x.....n.=..|
00000230  13 86 b6 a5 86 f9 a6 ef  ca 77 46 df 8d 3b eb fb  |.........wF..;..|
00000240  00 c8 61 cc fd 7a                                 |..a..z|
Linkable Ring Signature verified.
</pre>
</div>
</div>
<h2 id="HashVerify">func <a href="/src/github.com/dedis/crypto/proof/hash.go?s=3769:3867#L121">HashVerify</a>
<a class="permalink" href="#HashVerify">¶</a>
</h2>
<pre>func HashVerify(suite <a href="../../../../github.com/dedis/crypto/abstract/index.html">abstract</a>.<a href="../../../../github.com/dedis/crypto/abstract/index.html#Suite">Suite</a>, protocolName <a href="https://golang.org/pkg/builtin/#string">string</a>,
    verifier <a href="#Verifier">Verifier</a>, proof []<a href="https://golang.org/pkg/builtin/#byte">byte</a>) <a href="https://golang.org/pkg/builtin/#error">error</a></pre>
<p>
Verifies a hash-based noninteractive proof generated with HashProve.
The suite and protocolName must be the same as those given to HashProve.
Returns nil if the proof checks out, or an error on any failure.
</p>
<h2 id="Predicate">type <a href="/src/github.com/dedis/crypto/proof/proof.go?s=2583:3776#L44">Predicate</a>
<a class="permalink" href="#Predicate">¶</a>
</h2>
<pre>type Predicate interface {

    <span class="comment">// Create a Prover proving the statement this Predicate represents.</span>
    Prover(suite <a href="../../../../github.com/dedis/crypto/abstract/index.html">abstract</a>.<a href="../../../../github.com/dedis/crypto/abstract/index.html#Suite">Suite</a>, secrets map[<a href="https://golang.org/pkg/builtin/#string">string</a>]<a href="../../../../github.com/dedis/crypto/abstract/index.html">abstract</a>.<a href="../../../../github.com/dedis/crypto/abstract/index.html#Scalar">Scalar</a>,
        points map[<a href="https://golang.org/pkg/builtin/#string">string</a>]<a href="../../../../github.com/dedis/crypto/abstract/index.html">abstract</a>.<a href="../../../../github.com/dedis/crypto/abstract/index.html#Point">Point</a>, choice map[<a href="#Predicate">Predicate</a>]<a href="https://golang.org/pkg/builtin/#int">int</a>) <a href="#Prover">Prover</a>

    <span class="comment">// Create a Verifier for the statement this Predicate represents.</span>
    Verifier(suite <a href="../../../../github.com/dedis/crypto/abstract/index.html">abstract</a>.<a href="../../../../github.com/dedis/crypto/abstract/index.html#Suite">Suite</a>, points map[<a href="https://golang.org/pkg/builtin/#string">string</a>]<a href="../../../../github.com/dedis/crypto/abstract/index.html">abstract</a>.<a href="../../../../github.com/dedis/crypto/abstract/index.html#Point">Point</a>) <a href="#Verifier">Verifier</a>

    <span class="comment">// Produce a human-readable string representation of the predicate.</span>
    String() <a href="https://golang.org/pkg/builtin/#string">string</a>
    <span class="comment">// contains filtered or unexported methods</span>
}</pre>
<p>
A Predicate is a composable logic expression in a knowledge proof system,
representing a "knowledge specification set" in Camenisch/Stadler terminology.
Atomic predicates in this system are statements of the form P=x1*B1+...+xn+Bn,
indicating the prover knows secrets x1,...,xn that make the statement true,
where P and B1,...,Bn are public points known to the verifier.
These atomic Rep (representation) predicates may be combined
with logical And and Or combinators to form composite statements.
Predicate objects, once created, are immutable and safe to share
or reuse for any number of proofs and verifications.
</p>
<p>
After constructing a Predicate using the Rep, And, and Or functions below,
the caller invokes Prover() to create a Sigma-protocol prover.
Prover() requires maps defining the values of both the Scalar variables
and the public Point variables that the Predicate refers to.
If the statement contains logical Or operators, the caller must also pass
a map containing branch choices for each Or predicate
in the "proof-obligated path" down through the Or predicates.
See the examples provded for the Or function for more details.
</p>
<p>
Similarly, the caller may invoke Verifier() to create
a Sigma-protocol verifier for the predicate.
The caller must pass a map defining the values
of the public Point variables that the proof refers to.
The verifier need not be provided any secrets or branch choices, of course.
(If the verifier needed those then they wouldn't be secret, would they?)
</p>
<p>
Currently we require that all Or operators be above all And operators
in the expression - i.e., Or-of-And combinations are allowed,
but no And-of-Or predicates.
We could rewrite expressions into this form as Camenisch/Stadler suggest,
but that could run a risk of unexpected exponential blowup in the worst case.
We could avoid this risk by not rewriting the expression tree,
but instead generating Pedersen commits for variables that need to "cross"
from one OR-domain to another non-mutually-exclusive one.
For now we simply require expressions to be in the appropriate form.
</p>
<h3 id="And">func <a href="/src/github.com/dedis/crypto/proof/proof.go?s=10016:10052#L318">And</a>
<a class="permalink" href="#And">¶</a>
</h3>
<pre>func And(sub ...<a href="#Predicate">Predicate</a>) <a href="#Predicate">Predicate</a></pre>
<p>
An And predicate states that all of the constituent sub-predicates are true.
And predicates may contain Rep predicates and/or other And predicates.
</p>
<div class="toggle" id="example_And_1">
<div class="collapsed">
<p class="exampleHeading toggleButton">▹ <span class="text">Example (1)</span></p>
</div>
<div class="expanded">
<p class="exampleHeading toggleButton">▾ <span class="text">Example (1)</span></p>
<p>This code creates an And predicate indicating that
the prover knows two different secrets x and y,
such that point X is equal to x*B
and point Y is equal to y*B.
This predicate might be used to prove knowledge of
the private keys corresponding to two public keys X and Y, for example.
</p>
<p>Code:</p>
<pre class="code">pred := And(Rep("X", "x", "B"), Rep("Y", "y", "B"))
fmt.Println(pred.String())
<span class="comment"></span></pre>
<p>Output:</p>
<pre class="output">X=x*B &amp;&amp; Y=y*B
</pre>
</div>
</div>
<div class="toggle" id="example_And_2">
<div class="collapsed">
<p class="exampleHeading toggleButton">▹ <span class="text">Example (2)</span></p>
</div>
<div class="expanded">
<p class="exampleHeading toggleButton">▾ <span class="text">Example (2)</span></p>
<p>This code creates an And predicate indicating that
the prover knows a single secret value x,
such that point X1 is equal to x*B1
and point X2 is equal to x*B2.
Thus, the prover not only proves knowledge of the discrete logarithm
of X1 with respect to B1 and of X2 with respect to B2,
but also proves that those two discrete logarithms are equal.
</p>
<p>Code:</p>
<pre class="code">pred := And(Rep("X1", "x", "B1"), Rep("X2", "x", "B2"))
fmt.Println(pred.String())
<span class="comment"></span></pre>
<p>Output:</p>
<pre class="output">X1=x*B1 &amp;&amp; X2=x*B2
</pre>
</div>
</div>
<h3 id="Or">func <a href="/src/github.com/dedis/crypto/proof/proof.go?s=12566:12601#L430">Or</a>
<a class="permalink" href="#Or">¶</a>
</h3>
<pre>func Or(sub ...<a href="#Predicate">Predicate</a>) <a href="#Predicate">Predicate</a></pre>
<div class="toggle" id="example_Or_1">
<div class="collapsed">
<p class="exampleHeading toggleButton">▹ <span class="text">Example (1)</span></p>
</div>
<div class="expanded">
<p class="exampleHeading toggleButton">▾ <span class="text">Example (1)</span></p>
<p>This code creates an Or predicate indicating that
the prover either knows a secret x such that X=x*B,
or the prover knows a secret y such that Y=y*B.
This predicate in essence proves knowledge of the private key
for one of two public keys X or Y,
without revealing which key the prover owns.
</p>
<p>Code:</p>
<pre class="code">pred := Or(Rep("X", "x", "B"), Rep("Y", "y", "B"))
fmt.Println(pred.String())
<span class="comment"></span></pre>
<p>Output:</p>
<pre class="output">X=x*B || Y=y*B
</pre>
</div>
</div>
<div class="toggle" id="example_Or_2">
<div class="collapsed">
<p class="exampleHeading toggleButton">▹ <span class="text">Example (2)</span></p>
</div>
<div class="expanded">
<p class="exampleHeading toggleButton">▾ <span class="text">Example (2)</span></p>
<p>This code shows how to create and verify Or-predicate proofs,
such as the one above.
In this case, we know a secret x such that X=x*B,
but we don't know a secret y such that Y=y*B,
because we simply pick Y as a random point
instead of generating it by scalar multiplication.
(And if the group is cryptographically secure
we won't find be able to find such a y.)
</p>
<p>Code:</p>
<pre class="code"><span class="comment">// Create an Or predicate.</span>
pred := Or(Rep("X", "x", "B"), Rep("Y", "y", "B"))
fmt.Println("Predicate: " + pred.String())

<span class="comment">// Crypto setup</span>
suite := nist.NewAES128SHA256P256()
rand := suite.Cipher([]byte("example"))
B := suite.Point().Base() <span class="comment">// standard base point</span>

<span class="comment">// Create a public/private keypair (X,x) and a random point Y</span>
x := suite.Scalar().Pick(rand)        <span class="comment">// create a private key x</span>
X := suite.Point().Mul(nil, x)        <span class="comment">// corresponding public key X</span>
Y, _ := suite.Point().Pick(nil, rand) <span class="comment">// pick a random point Y</span>

<span class="comment">// We'll need to tell the prover which Or clause is actually true.</span>
<span class="comment">// In this case clause 0, the first sub-predicate, is true:</span>
<span class="comment">// i.e., we know a secret x such that X=x*B.</span>
choice := make(map[Predicate]int)
choice[pred] = 0

<span class="comment">// Generate a proof that we know the discrete logarithm of X or Y.</span>
sval := map[string]abstract.Scalar{"x": x}
pval := map[string]abstract.Point{"B": B, "X": X, "Y": Y}
prover := pred.Prover(suite, sval, pval, choice)
proof, _ := HashProve(suite, "TEST", rand, prover)
fmt.Print("Proof:\n" + hex.Dump(proof))

<span class="comment">// Verify this knowledge proof.</span>
<span class="comment">// The verifier doesn't need the secret values or choice map, of course.</span>
verifier := pred.Verifier(suite, pval)
err := HashVerify(suite, "TEST", verifier, proof)
if err != nil {
    panic("proof failed to verify!")
}
fmt.Println("Proof verified.")

<span class="comment"></span></pre>
<p>Output:</p>
<pre class="output">Predicate: X=x*B || Y=y*B
Proof:
00000000  04 af 84 ed e5 86 04 cf  81 e4 18 17 84 0c 39 ab  |..............9.|
00000010  fe 5c bc cc 00 85 e0 a2  ee aa d5 22 18 dd c4 a1  |.\........."....|
00000020  5b 85 52 d4 dd 72 9b d2  2b e2 02 d2 5f 6f cb 10  |[.R..r..+..._o..|
00000030  b5 1b 18 c3 02 1e 2f dd  50 54 9d 4c 19 aa 30 80  |....../.PT.L..0.|
00000040  4a 04 f8 26 2f 55 ed b3  00 ad 38 ba f9 0f d6 fb  |J..&amp;/U....8.....|
00000050  0a d1 0e 56 be dd 71 7d  1d a9 36 2f 1f 20 b8 98  |...V..q}..6/. ..|
00000060  a6 3f d0 fa dc 52 ca 57  8d 7e 37 aa ac e5 8c 4c  |.?...R.W.~7....L|
00000070  2a eb d9 5c 0c 68 c8 e8  ac 99 7f b4 96 56 cf 59  |*..\.h.......V.Y|
00000080  79 6f c5 c2 0a 9f 1f 3b  34 61 0f 9b b7 50 00 b7  |yo.....;4a...P..|
00000090  29 02 8e d5 41 9a 92 95  6b 4e 18 5b 89 a5 93 1e  |)...A...kN.[....|
000000a0  42 cd 32 17 7d 53 c5 e4  48 79 49 b2 3e 1e e2 62  |B.2.}S..HyI.&gt;..b|
000000b0  39 08 13 d5 2e f8 c5 e9  c1 28 09 91 7a 95 c9 12  |9........(..z...|
000000c0  17 85 49 9e b0 3c fe fc  5d 5b 73 b1 d2 bf f9 59  |..I..&lt;..][s....Y|
000000d0  5b 5f 10 12 cb 9c d0 c6  bc 2c 75 fb 52 9c 66 c5  |[_.......,u.R.f.|
000000e0  17 cb 93 8b c6 f6 34 12  83 a0 32 2e 82 2c 4b fb  |......4...2..,K.|
000000f0  b3 0c a1 4b a5 e3 27 43  b6 2f ed fa ca 4f 93 83  |...K..'C./...O..|
00000100  fd 56                                             |.V|
Proof verified.
</pre>
</div>
</div>
<h3 id="Rep">func <a href="/src/github.com/dedis/crypto/proof/proof.go?s=5952:5994#L143">Rep</a>
<a class="permalink" href="#Rep">¶</a>
</h3>
<pre>func Rep(P <a href="https://golang.org/pkg/builtin/#string">string</a>, SB ...<a href="https://golang.org/pkg/builtin/#string">string</a>) <a href="#Predicate">Predicate</a></pre>
<p>
Rep creates a predicate stating that the prover knows
a representation of a point P with respect to
one or more secrets and base point pairs.
</p>
<p>
In its simplest usage, Rep indicates that the prover knows a secret x
that is the (elliptic curve) discrete logarithm of a public point P
with respect to a well-known base point B:
</p>
<pre>Rep(P,x,B)
</pre>
<p>
Rep can take any number of (Scalar,Base) variable name pairs, however.
A Rep statement of the form Rep(P,x1,B1,...,xn,Bn)
indicates that the prover knows secrets x1,...,xn
such that point P is the sum x1*B1+...+xn*Bn.
</p>
<div class="toggle" id="example_Rep_1">
<div class="collapsed">
<p class="exampleHeading toggleButton">▹ <span class="text">Example (1)</span></p>
</div>
<div class="expanded">
<p class="exampleHeading toggleButton">▾ <span class="text">Example (1)</span></p>
<p>This code creates a simple discrete logarithm knowledge proof.
In particular, that the prover knows a secret x
that is the elliptic curve discrete logarithm of a point X
with respect to some base B: i.e., X=x*B.
If we take X as a public key and x as its corresponding private key,
then this constitutes a "proof of ownership" of the public key X.
</p>
<p>Code:</p>
<pre class="code">pred := Rep("X", "x", "B")
fmt.Println(pred.String())
<span class="comment"></span></pre>
<p>Output:</p>
<pre class="output">X=x*B
</pre>
</div>
</div>
<div class="toggle" id="example_Rep_2">
<div class="collapsed">
<p class="exampleHeading toggleButton">▹ <span class="text">Example (2)</span></p>
</div>
<div class="expanded">
<p class="exampleHeading toggleButton">▾ <span class="text">Example (2)</span></p>
<p>This example shows how to generate and verify noninteractive proofs
of the statement in the example above, i.e.,
a proof of ownership of public key X.
</p>
<p>Code:</p>
<pre class="code">pred := Rep("X", "x", "B")
fmt.Println(pred.String())

<span class="comment">// Crypto setup</span>
suite := nist.NewAES128SHA256P256()
rand := suite.Cipher([]byte("example"))
B := suite.Point().Base() <span class="comment">// standard base point</span>

<span class="comment">// Create a public/private keypair (X,x)</span>
x := suite.Scalar().Pick(rand) <span class="comment">// create a private key x</span>
X := suite.Point().Mul(nil, x) <span class="comment">// corresponding public key X</span>

<span class="comment">// Generate a proof that we know the discrete logarithm of X.</span>
sval := map[string]abstract.Scalar{"x": x}
pval := map[string]abstract.Point{"B": B, "X": X}
prover := pred.Prover(suite, sval, pval, nil)
proof, _ := HashProve(suite, "TEST", rand, prover)
fmt.Print("Proof:\n" + hex.Dump(proof))

<span class="comment">// Verify this knowledge proof.</span>
verifier := pred.Verifier(suite, pval)
err := HashVerify(suite, "TEST", verifier, proof)
if err != nil {
    panic("proof failed to verify!")
}
fmt.Println("Proof verified.")

<span class="comment"></span></pre>
<p>Output:</p>
<pre class="output">X=x*B
Proof:
00000000  04 23 62 b1 f9 cb f4 a2  6d 7f 3e 69 cb b6 77 ab  |.#b.....m.&gt;i..w.|
00000010  90 fc 7c db a0 c6 e8 12  f2 0a d4 40 a4 b6 c4 de  |..|........@....|
00000020  9e e8 61 88 5e 50 fd 03  a9 ff 9c a3 c4 29 f7 18  |..a.^P.......)..|
00000030  49 ad 31 0e f9 17 15 1e  3b 8d 0e 2f b2 c4 28 32  |I.1.....;../..(2|
00000040  4a 20 ba b2 9d 3a 40 ae  0f 28 16 a2 ad 44 76 d2  |J ...:@..(...Dv.|
00000050  83 f2 09 4d b8 a5 d0 f6  5e 5d ff 6e b7 9a 0f 1b  |...M....^].n....|
00000060  9a                                                |.|
Proof verified.
</pre>
</div>
</div>
<div class="toggle" id="example_Rep_3">
<div class="collapsed">
<p class="exampleHeading toggleButton">▹ <span class="text">Example (3)</span></p>
</div>
<div class="expanded">
<p class="exampleHeading toggleButton">▾ <span class="text">Example (3)</span></p>
<p>This code creates a predicate stating that the prover knows a representation
of point X with respect to two different bases B1 and B2.
This means the prover knows two secrets x1 and x2
such that X=x1*B1+x2*B2.

Point X might constitute a Pedersen commitment, for example,
where x1 is the value being committed to and x2 is a random blinding factor.
Assuming the discrete logarithm problem is hard in the relevant group
and the logarithmic relationship between bases B1 and B2 is unknown -
which we would be true if B1 and B2 are chosen at random, for example -
then a prover who has committed to point P
will later be unable to "open" the commitment
using anything other than secrets x1 and x2.
The prover can also prove that one of the secrets (say x1)
is equal to a secret used in the representation of some other point,
while leaving the other secret (x2) unconstrained.

If the prover does know the relationship between B1 and B2, however,
then X does not serve as a useful commitment:
the prover can trivially compute the x1 corresponding to an arbitrary x2.
</p>
<p>Code:</p>
<pre class="code">pred := Rep("X", "x1", "B1", "x2", "B2")
fmt.Println(pred.String())
<span class="comment"></span></pre>
<p>Output:</p>
<pre class="output">X=x1*B1+x2*B2
</pre>
</div>
</div>
<h2 id="Prover">type <a href="/src/github.com/dedis/crypto/proof/context.go?s=528:569#L1">Prover</a>
<a class="permalink" href="#Prover">¶</a>
</h2>
<pre>type Prover func(ctx <a href="#ProverContext">ProverContext</a>) <a href="https://golang.org/pkg/builtin/#error">error</a></pre>
<p>
Prover represents the prover role in an arbitrary Sigma-protocol.
A prover is simply a higher-order function that takes a ProverContext,
runs the protocol while making calls to the ProverContext methods as needed,
and returns nil on success or an error once the protocol run concludes.
The resulting proof is embodied in the interactions with the ProverContext,
but HashProve() may be used to encode the proof into a non-interactive proof
using a hash function via the Fiat-Shamir heuristic.
</p>
<h2 id="ProverContext">type <a href="/src/github.com/dedis/crypto/proof/context.go?s=1784:2012#L26">ProverContext</a>
<a class="permalink" href="#ProverContext">¶</a>
</h2>
<pre>type ProverContext interface {
    Put(message interface{}) <a href="https://golang.org/pkg/builtin/#error">error</a>        <span class="comment">// Send message to verifier</span>
    PubRand(message ...interface{}) <a href="https://golang.org/pkg/builtin/#error">error</a> <span class="comment">// Get public randomness</span>
    PriRand(message ...interface{})       <span class="comment">// Get private randomness</span>
}</pre>
<p>
ProverContext represents the abstract environment
required by the prover in a Sigma protocol.
</p>
<p>
In a basic 3-step Sigma protocol such as a standard digital signature,
the prover first calls Put() one or more times
to send commitment information to the verifier,
then calls PubRand() to obtain a public random challenge from the verifier,
and finally makes further calls to Put() to respond to the challenge.
</p>
<p>
The prover may also call PriRand() at any time
to obtain any private randomness needed in the proof.
The prover should obtain secret randomness only from this source,
so that the prover may be run deterministically if desired.
</p>
<p>
More sophisticated Sigma protocols requiring more than 3 steps,
such as the Neff shuffle, may also use this interface;
in this case the prover simply calls PubRand() multiple times.
</p>
<h2 id="Verifier">type <a href="/src/github.com/dedis/crypto/proof/context.go?s=868:913#L6">Verifier</a>
<a class="permalink" href="#Verifier">¶</a>
</h2>
<pre>type Verifier func(ctx <a href="#VerifierContext">VerifierContext</a>) <a href="https://golang.org/pkg/builtin/#error">error</a></pre>
<p>
Verifier represents the verifier role in an arbitrary Sigma-protocol.
A verifier is a higher-order function that takes a VerifierContext,
runs the protocol while making calls to VerifierContext methods as needed,
and returns nil on success or an error once the protocol run concludes.
</p>
<h2 id="VerifierContext">type <a href="/src/github.com/dedis/crypto/proof/context.go?s=2637:2805#L43">VerifierContext</a>
<a class="permalink" href="#VerifierContext">¶</a>
</h2>
<pre>type VerifierContext interface {
    Get(message interface{}) <a href="https://golang.org/pkg/builtin/#error">error</a>        <span class="comment">// Receive message from prover</span>
    PubRand(message ...interface{}) <a href="https://golang.org/pkg/builtin/#error">error</a> <span class="comment">// Get public randomness</span>
}</pre>
<p>
ProverContext represents the abstract environment
required by the verifier in a Sigma protocol.
</p>
<p>
The verifier calls Get() to obtain the prover's message data,
interspersed with calls to PubRand() to obtain challenge data.
Note that the challenge itself comes from the VerifierContext,
not from the verifier itself as in the traditional Sigma-protocol model.
By separating challenge production from proof verification logic,
we obtain the flexibility to use a single Verifier function
in both non-interactive proofs (e.g., via HashProve)
and in interactive proofs (e.g., via DeniableProver).
</p>

</div><!-- .container -->
</div><!-- #page -->
<!-- TODO(adonovan): load these from <head> using "defer" attribute? -->
<script src="../../../../.goduckstyle/jquery.js" type="text/javascript"></script>
<script src="../../../../.goduckstyle/jquery.treeview.js" type="text/javascript"></script>
<script src="../../../../.goduckstyle/jquery.treeview.edit.js" type="text/javascript"></script>
<script>var goVersion = "go1.7.1";</script>
<script src="../../../../.goduckstyle/godocs.js" type="text/javascript"></script>
</body>
</html>
