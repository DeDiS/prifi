<!DOCTYPE html>

<html>
<head>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type">
<meta content="width=device-width, initial-scale=1" name="viewport">
<meta content="#375EAB" name="theme-color">
<title>cosi - The PriFi Project</title>
<link href="../../../../.goduckstyle/style.css" rel="stylesheet" type="text/css">
<link href="../../../../.goduckstyle/jquery.treeview.css" rel="stylesheet">
<script type="text/javascript">window.initFuncs = [];</script>
</link></link></meta></meta></meta></head>
<body>
<div id="lowframe" style="position: fixed; bottom: 0; left: 0; height: 0; width: 100%; border-top: thin solid grey; background-color: white; overflow: auto;">
...
</div><!-- #lowframe -->
<div class="wide" id="topbar"><div class="container">
<div class="top-heading" id="heading-wide">The PriFi Project</div>
<div class="top-heading" id="heading-narrow"><a href="/">Go</a></div>
<a href="#" id="menu-button"><span id="menu-button-arrow">▽</span></a>
<form action="/search" method="GET">
<div id="menu">





</div>
</form>
</div></div>
<div class="wide" id="page">
<div class="container">
<h1>Package cosi</h1>
<div id="nav"></div>
<!--
	Copyright 2009 The Go Authors. All rights reserved.
	Use of this source code is governed by a BSD-style
	license that can be found in the LICENSE file.
-->
<!--
	Note: Static (i.e., not template-generated) href and id
	attributes start with "pkg-" to make it impossible for
	them to conflict with generated attributes (some of which
	correspond to Go identifiers).
-->
<script type="text/javascript">
	document.ANALYSIS_DATA = null;
	document.CALLGRAPH = null;
	</script>
<div id="short-nav">
<dl>
<dd><code>import "github.com/dedis/crypto/cosi"</code></dd>
</dl>
<dl>
<dd><a class="overviewLink" href="#pkg-overview">Overview</a></dd>
<dd><a class="indexLink" href="#pkg-index">Index</a></dd>
</dl>
</div>
<!-- The package's Name is printed as title by the top-level template -->
<div class="toggleVisible" id="pkg-overview">
<div class="collapsed">
<h2 class="toggleButton" title="Click to show Overview section">Overview ▹</h2>
</div>
<div class="expanded">
<h2 class="toggleButton" title="Click to hide Overview section">Overview ▾</h2>
<p>
Package cosi is the Collective Signing implementation according to the paper of
Bryan Ford: <a href="http://arxiv.org/pdf/1503.08768v1.pdf">http://arxiv.org/pdf/1503.08768v1.pdf</a> .
</p>
<h3 id="hdr-Stages_of_CoSi">Stages of CoSi</h3>
<p>
The CoSi-protocol has 4 stages:
</p>
<p>
1. Announcement: The leader multicasts an announcement
of the start of this round down through the spanning tree,
optionally including the statement S to be signed.
</p>
<p>
2. Commitment: Each node i picks a random scalar vi and
computes its individual commit Vi = Gvi . In a bottom-up
process, each node i waits for an aggregate commit Vˆj from
each immediate child j, if any. Node i then computes its
own aggregate commit Vˆi = Vi \prod{j ∈ Cj}{Vˆj}, where Ci is the
set of i’s immediate children. Finally, i passes Vi up to its
parent, unless i is the leader (node 0).
</p>
<p>
3. Challenge: The leader computes a collective challenge
c = H( Aggregate Commit ∥ Aggregate Public key || Message ),
then multicasts c down through the tree, along
with the statement S to be signed if it was not already
announced in phase 1.
</p>
<p>
4. Response: In a final bottom-up phase, each node i waits
to receive a partial aggregate response rˆj from each of
its immediate children j ∈ Ci. Node i now computes its
individual response ri = vi + cxi, and its partial aggregate
response rˆi = ri + \sum{j ∈ Cj}{rˆj} . Node i finally passes rˆi
up to its parent, unless i is the root.
</p>
</div>
</div>
<div class="toggleVisible" id="pkg-index">
<div class="collapsed">
<h2 class="toggleButton" title="Click to show Index section">Index ▹</h2>
</div>
<div class="expanded">
<h2 class="toggleButton" title="Click to hide Index section">Index ▾</h2>
<!-- Table of contents for API; must be named manual-nav to turn off auto nav. -->
<div id="manual-nav">
<dl>
<dd><a href="#VerifySignature">func VerifySignature(suite abstract.Suite, publics []abstract.Point, message, sig []byte) error</a></dd>
<dd><a href="#CoSi">type CoSi</a></dd>
<dd>    <a href="#NewCosi">func NewCosi(suite abstract.Suite, private abstract.Scalar, publics []abstract.Point) *CoSi</a></dd>
<dd>    <a href="#CoSi.Aggregate">func (cm CoSi) Aggregate() abstract.Point</a></dd>
<dd>    <a href="#CoSi.AggregateResponse">func (c *CoSi) AggregateResponse() abstract.Scalar</a></dd>
<dd>    <a href="#CoSi.Challenge">func (c *CoSi) Challenge(challenge abstract.Scalar)</a></dd>
<dd>    <a href="#CoSi.Commit">func (c *CoSi) Commit(s cipher.Stream, subComms []abstract.Point) abstract.Point</a></dd>
<dd>    <a href="#CoSi.CreateChallenge">func (c *CoSi) CreateChallenge(msg []byte) (abstract.Scalar, error)</a></dd>
<dd>    <a href="#CoSi.CreateCommitment">func (c *CoSi) CreateCommitment(s cipher.Stream) abstract.Point</a></dd>
<dd>    <a href="#CoSi.CreateResponse">func (c *CoSi) CreateResponse() (abstract.Scalar, error)</a></dd>
<dd>    <a href="#CoSi.GetChallenge">func (c *CoSi) GetChallenge() abstract.Scalar</a></dd>
<dd>    <a href="#CoSi.GetCommitment">func (c *CoSi) GetCommitment() abstract.Point</a></dd>
<dd>    <a href="#CoSi.GetResponse">func (c *CoSi) GetResponse() abstract.Scalar</a></dd>
<dd>    <a href="#CoSi.MaskBit">func (cm CoSi) MaskBit(signer int) bool</a></dd>
<dd>    <a href="#CoSi.MaskLen">func (cm CoSi) MaskLen() int</a></dd>
<dd>    <a href="#CoSi.Response">func (c *CoSi) Response(responses []abstract.Scalar) (abstract.Scalar, error)</a></dd>
<dd>    <a href="#CoSi.SetMask">func (cm CoSi) SetMask(mask []byte) error</a></dd>
<dd>    <a href="#CoSi.SetMaskBit">func (cm CoSi) SetMaskBit(signer int, enabled bool)</a></dd>
<dd>    <a href="#CoSi.Signature">func (c *CoSi) Signature() []byte</a></dd>
<dd>    <a href="#CoSi.VerifyResponses">func (c *CoSi) VerifyResponses(aggregatedPublic abstract.Point) error</a></dd>
</dl>
</div><!-- #manual-nav -->
<h4>Package files</h4>
<p>
<span style="font-size:90%">
<a href="/src/github.com/dedis/crypto/cosi/cosi.go">cosi.go</a>
</span>
</p>
</div><!-- .expanded -->
</div><!-- #pkg-index -->
<div class="toggle" id="pkg-callgraph" style="display: none">
<div class="collapsed">
<h2 class="toggleButton" title="Click to show Internal Call Graph section">Internal call graph ▹</h2>
</div> <!-- .expanded -->
<div class="expanded">
<h2 class="toggleButton" title="Click to hide Internal Call Graph section">Internal call graph ▾</h2>
<p>
			  In the call graph viewer below, each node
			  is a function belonging to this package
			  and its children are the functions it
			  calls—perhaps dynamically.
			</p>
<p>
			  The root nodes are the entry points of the
			  package: functions that may be called from
			  outside the package.
			  There may be non-exported or anonymous
			  functions among them if they are called
			  dynamically from another package.
			</p>
<p>
			  Click a node to visit that function's source code.
			  From there you can visit its callers by
			  clicking its declaring <code>func</code>
			  token.
			</p>
<p>
			  Functions may be omitted if they were
			  determined to be unreachable in the
			  particular programs or tests that were
			  analyzed.
			</p>
<!-- Zero means show all package entry points. -->
<ul class="treeview" id="callgraph-0" style="margin-left: 0.5in"></ul>
</div>
</div> <!-- #pkg-callgraph -->
<h2 id="VerifySignature">func <a href="/src/github.com/dedis/crypto/cosi/cosi.go?s=8834:8929#L222">VerifySignature</a>
<a class="permalink" href="#VerifySignature">¶</a>
</h2>
<pre>func VerifySignature(suite <a href="../../../../github.com/dedis/crypto/abstract/index.html">abstract</a>.<a href="../../../../github.com/dedis/crypto/abstract/index.html#Suite">Suite</a>, publics []<a href="../../../../github.com/dedis/crypto/abstract/index.html">abstract</a>.<a href="../../../../github.com/dedis/crypto/abstract/index.html#Point">Point</a>, message, sig []<a href="https://golang.org/pkg/builtin/#byte">byte</a>) <a href="https://golang.org/pkg/builtin/#error">error</a></pre>
<p>
VerifySignature is the method to call to verify a signature issued by a Cosi
struct. Publics is the WHOLE list of publics keys, the mask at the end of the
signature will take care of removing the indivual public keys that did not
participate
</p>
<h2 id="CoSi">type <a href="/src/github.com/dedis/crypto/cosi/cosi.go?s=3081:4108#L60">CoSi</a>
<a class="permalink" href="#CoSi">¶</a>
</h2>
<pre>type CoSi struct {
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
<p>
CoSi is the struct that implements one round of a CoSi protocol.
It's important to only use this struct *once per round*, and if you  try to
use it twice, it will try to alert you if it can.
You create a CoSi struct by giving your secret key you wish to pariticipate
with during the CoSi protocol, and the list of public keys representing the
list of all co-signer's public keys involved in the round.
To use CoSi, call three different functions on it which corresponds to the last
three phases of the protocols:
</p>
<pre>- (Create)Commitment: creates a new secret and its commitment. The output has to
be passed up to the parent in the tree.
- CreateChallenge: the root creates the challenge from receiving all the
commitments. This output must be sent down the tree using Challenge()
function.
- (Create)Response: creates and possibly aggregates all responses and the
output must be sent up into the tree.
</pre>
<p>
The root can then issue `Signature()` to get the final signature that can be
verified using `VerifySignature()`.
To handle missing signers, the signature generation will append a bitmask at
the end of the signature with each bit index set corresponding to a missing
cosigner. If you need to specify a missing signer, you can call
SetMaskBit(i int, enabled bool) which will set the signer i disabled in the
mask. The index comes from the list of public keys you give when creating the
CoSi struct. You can also give the full mask directly with SetMask().
</p>
<h3 id="NewCosi">func <a href="/src/github.com/dedis/crypto/cosi/cosi.go?s=4462:4553#L93">NewCosi</a>
<a class="permalink" href="#NewCosi">¶</a>
</h3>
<pre>func NewCosi(suite <a href="../../../../github.com/dedis/crypto/abstract/index.html">abstract</a>.<a href="../../../../github.com/dedis/crypto/abstract/index.html#Suite">Suite</a>, private <a href="../../../../github.com/dedis/crypto/abstract/index.html">abstract</a>.<a href="../../../../github.com/dedis/crypto/abstract/index.html#Scalar">Scalar</a>, publics []<a href="../../../../github.com/dedis/crypto/abstract/index.html">abstract</a>.<a href="../../../../github.com/dedis/crypto/abstract/index.html#Point">Point</a>) *<a href="#CoSi">CoSi</a></pre>
<p>
NewCosi returns a new Cosi struct given the suite, the longterm secret, and
the list of public keys. If some signers were not to be participating, you
have to set the mask using `SetMask` method. By default, all participants are
designated as participating. If you wish to specify which co-signers are
participating, use NewCosiWithMask
</p>
<h3 id="CoSi.Aggregate">func (CoSi) <a href="/src/github.com/dedis/crypto/cosi/cosi.go?s=14861:14903#L434">Aggregate</a>
<a class="permalink" href="#CoSi.Aggregate">¶</a>
</h3>
<pre>func (cm <a href="#CoSi">CoSi</a>) Aggregate() <a href="../../../../github.com/dedis/crypto/abstract/index.html">abstract</a>.<a href="../../../../github.com/dedis/crypto/abstract/index.html#Point">Point</a></pre>
<p>
Aggregate returns the aggregate public key of all *participating* signers
</p>
<h3 id="CoSi.AggregateResponse">func (*CoSi) <a href="/src/github.com/dedis/crypto/cosi/cosi.go?s=9966:10016#L263">AggregateResponse</a>
<a class="permalink" href="#CoSi.AggregateResponse">¶</a>
</h3>
<pre>func (c *<a href="#CoSi">CoSi</a>) AggregateResponse() <a href="../../../../github.com/dedis/crypto/abstract/index.html">abstract</a>.<a href="../../../../github.com/dedis/crypto/abstract/index.html#Scalar">Scalar</a></pre>
<p>
AggregateResponse returns the aggregated response that this cosi has
accumulated.
</p>
<h3 id="CoSi.Challenge">func (*CoSi) <a href="/src/github.com/dedis/crypto/cosi/cosi.go?s=6241:6292#L147">Challenge</a>
<a class="permalink" href="#CoSi.Challenge">¶</a>
</h3>
<pre>func (c *<a href="#CoSi">CoSi</a>) Challenge(challenge <a href="../../../../github.com/dedis/crypto/abstract/index.html">abstract</a>.<a href="../../../../github.com/dedis/crypto/abstract/index.html#Scalar">Scalar</a>)</pre>
<p>
Challenge keeps in memory the Challenge from the message.
</p>
<h3 id="CoSi.Commit">func (*CoSi) <a href="/src/github.com/dedis/crypto/cosi/cosi.go?s=5176:5256#L113">Commit</a>
<a class="permalink" href="#CoSi.Commit">¶</a>
</h3>
<pre>func (c *<a href="#CoSi">CoSi</a>) Commit(s <a href="../../../../crypto/cipher/index.html">cipher</a>.<a href="../../../../crypto/cipher/index.html#Stream">Stream</a>, subComms []<a href="../../../../github.com/dedis/crypto/abstract/index.html">abstract</a>.<a href="../../../../github.com/dedis/crypto/abstract/index.html#Point">Point</a>) <a href="../../../../github.com/dedis/crypto/abstract/index.html">abstract</a>.<a href="../../../../github.com/dedis/crypto/abstract/index.html#Point">Point</a></pre>
<p>
Commit creates the commitment / secret as in CreateCommitment and it also
aggregate children commitments from the children's messages.
</p>
<h3 id="CoSi.CreateChallenge">func (*CoSi) <a href="/src/github.com/dedis/crypto/cosi/cosi.go?s=5717:5784#L129">CreateChallenge</a>
<a class="permalink" href="#CoSi.CreateChallenge">¶</a>
</h3>
<pre>func (c *<a href="#CoSi">CoSi</a>) CreateChallenge(msg []<a href="https://golang.org/pkg/builtin/#byte">byte</a>) (<a href="../../../../github.com/dedis/crypto/abstract/index.html">abstract</a>.<a href="../../../../github.com/dedis/crypto/abstract/index.html#Scalar">Scalar</a>, <a href="https://golang.org/pkg/builtin/#error">error</a>)</pre>
<p>
CreateChallenge creates the challenge out of the message it has been given.
This is typically called by Root.
</p>
<h3 id="CoSi.CreateCommitment">func (*CoSi) <a href="/src/github.com/dedis/crypto/cosi/cosi.go?s=4929:4992#L106">CreateCommitment</a>
<a class="permalink" href="#CoSi.CreateCommitment">¶</a>
</h3>
<pre>func (c *<a href="#CoSi">CoSi</a>) CreateCommitment(s <a href="../../../../crypto/cipher/index.html">cipher</a>.<a href="../../../../crypto/cipher/index.html#Stream">Stream</a>) <a href="../../../../github.com/dedis/crypto/abstract/index.html">abstract</a>.<a href="../../../../github.com/dedis/crypto/abstract/index.html#Point">Point</a></pre>
<p>
CreateCommitment creates the commitment of a random secret generated from the
given s stream. It returns the message to pass up in the tree. This is
typically called by the leaves.
</p>
<h3 id="CoSi.CreateResponse">func (*CoSi) <a href="/src/github.com/dedis/crypto/cosi/cosi.go?s=6489:6545#L154">CreateResponse</a>
<a class="permalink" href="#CoSi.CreateResponse">¶</a>
</h3>
<pre>func (c *<a href="#CoSi">CoSi</a>) CreateResponse() (<a href="../../../../github.com/dedis/crypto/abstract/index.html">abstract</a>.<a href="../../../../github.com/dedis/crypto/abstract/index.html#Scalar">Scalar</a>, <a href="https://golang.org/pkg/builtin/#error">error</a>)</pre>
<p>
CreateResponse is called by a leaf to create its own response from the
challenge + commitment + private key. It returns the response to send up to
the tree.
</p>
<h3 id="CoSi.GetChallenge">func (*CoSi) <a href="/src/github.com/dedis/crypto/cosi/cosi.go?s=10124:10169#L268">GetChallenge</a>
<a class="permalink" href="#CoSi.GetChallenge">¶</a>
</h3>
<pre>func (c *<a href="#CoSi">CoSi</a>) GetChallenge() <a href="../../../../github.com/dedis/crypto/abstract/index.html">abstract</a>.<a href="../../../../github.com/dedis/crypto/abstract/index.html#Scalar">Scalar</a></pre>
<p>
GetChallenge returns the challenge that were passed down to this cosi.
</p>
<h3 id="CoSi.GetCommitment">func (*CoSi) <a href="/src/github.com/dedis/crypto/cosi/cosi.go?s=10276:10321#L273">GetCommitment</a>
<a class="permalink" href="#CoSi.GetCommitment">¶</a>
</h3>
<pre>func (c *<a href="#CoSi">CoSi</a>) GetCommitment() <a href="../../../../github.com/dedis/crypto/abstract/index.html">abstract</a>.<a href="../../../../github.com/dedis/crypto/abstract/index.html#Point">Point</a></pre>
<p>
GetCommitment returns the commitment generated by this CoSi (not aggregated).
</p>
<h3 id="CoSi.GetResponse">func (*CoSi) <a href="/src/github.com/dedis/crypto/cosi/cosi.go?s=10418:10462#L278">GetResponse</a>
<a class="permalink" href="#CoSi.GetResponse">¶</a>
</h3>
<pre>func (c *<a href="#CoSi">CoSi</a>) GetResponse() <a href="../../../../github.com/dedis/crypto/abstract/index.html">abstract</a>.<a href="../../../../github.com/dedis/crypto/abstract/index.html#Scalar">Scalar</a></pre>
<p>
GetResponse returns the individual response generated by this CoSi
</p>
<h3 id="CoSi.MaskBit">func (CoSi) <a href="/src/github.com/dedis/crypto/cosi/cosi.go?s=14280:14320#L412">MaskBit</a>
<a class="permalink" href="#CoSi.MaskBit">¶</a>
</h3>
<pre>func (cm <a href="#CoSi">CoSi</a>) MaskBit(signer <a href="https://golang.org/pkg/builtin/#int">int</a>) <a href="https://golang.org/pkg/builtin/#bool">bool</a></pre>
<p>
MaskBit returns a boolean value indicating whether
the indicated signer is enabled (true) or disabled (false)
</p>
<h3 id="CoSi.MaskLen">func (CoSi) <a href="/src/github.com/dedis/crypto/cosi/cosi.go?s=13528:13557#L386">MaskLen</a>
<a class="permalink" href="#CoSi.MaskLen">¶</a>
</h3>
<pre>func (cm <a href="#CoSi">CoSi</a>) MaskLen() <a href="https://golang.org/pkg/builtin/#int">int</a></pre>
<p>
MaskLen returns the length in bytes
of a complete disable-mask for this cosigner list.
</p>
<h3 id="CoSi.Response">func (*CoSi) <a href="/src/github.com/dedis/crypto/cosi/cosi.go?s=6703:6780#L161">Response</a>
<a class="permalink" href="#CoSi.Response">¶</a>
</h3>
<pre>func (c *<a href="#CoSi">CoSi</a>) Response(responses []<a href="../../../../github.com/dedis/crypto/abstract/index.html">abstract</a>.<a href="../../../../github.com/dedis/crypto/abstract/index.html#Scalar">Scalar</a>) (<a href="../../../../github.com/dedis/crypto/abstract/index.html">abstract</a>.<a href="../../../../github.com/dedis/crypto/abstract/index.html#Scalar">Scalar</a>, <a href="https://golang.org/pkg/builtin/#error">error</a>)</pre>
<p>
Response generates the response from the commitment, challenge and the
responses of its children.
</p>
<h3 id="CoSi.SetMask">func (CoSi) <a href="/src/github.com/dedis/crypto/cosi/cosi.go?s=12740:12782#L358">SetMask</a>
<a class="permalink" href="#CoSi.SetMask">¶</a>
</h3>
<pre>func (cm <a href="#CoSi">CoSi</a>) SetMask(mask []<a href="https://golang.org/pkg/builtin/#byte">byte</a>) <a href="https://golang.org/pkg/builtin/#error">error</a></pre>
<p>
Set the entire participation bitmask according to the provided
packed byte-slice interpreted in little-endian byte-order.
That is, bits 0-7 of the first byte correspond to cosigners 0-7,
bits 0-7 of the next byte correspond to cosigners 8-15, etc.
Each bit is set to indicate the corresponding cosigner is disabled,
or cleared to indicate the cosigner is enabled.
</p>
<p>
If the mask provided is too short (or nil),
SetMask conservatively interprets the bits of the missing bytes
to be 0, or Enabled.
</p>
<h3 id="CoSi.SetMaskBit">func (CoSi) <a href="/src/github.com/dedis/crypto/cosi/cosi.go?s=13673:13725#L391">SetMaskBit</a>
<a class="permalink" href="#CoSi.SetMaskBit">¶</a>
</h3>
<pre>func (cm <a href="#CoSi">CoSi</a>) SetMaskBit(signer <a href="https://golang.org/pkg/builtin/#int">int</a>, enabled <a href="https://golang.org/pkg/builtin/#bool">bool</a>)</pre>
<p>
SetMaskBit enables or disables the mask bit for an individual cosigner.
</p>
<h3 id="CoSi.Signature">func (*CoSi) <a href="/src/github.com/dedis/crypto/cosi/cosi.go?s=7339:7372#L179">Signature</a>
<a class="permalink" href="#CoSi.Signature">¶</a>
</h3>
<pre>func (c *<a href="#CoSi">CoSi</a>) Signature() []<a href="https://golang.org/pkg/builtin/#byte">byte</a></pre>
<p>
Signature returns a signature using the same format as EdDSA signature
AggregateCommit || AggregateResponse || Mask
*NOTE*: Signature() is only intended to be called by the root since only the
root knows the aggregate response.
</p>
<h3 id="CoSi.VerifyResponses">func (*CoSi) <a href="/src/github.com/dedis/crypto/cosi/cosi.go?s=8034:8103#L200">VerifyResponses</a>
<a class="permalink" href="#CoSi.VerifyResponses">¶</a>
</h3>
<pre>func (c *<a href="#CoSi">CoSi</a>) VerifyResponses(aggregatedPublic <a href="../../../../github.com/dedis/crypto/abstract/index.html">abstract</a>.<a href="../../../../github.com/dedis/crypto/abstract/index.html#Point">Point</a>) <a href="https://golang.org/pkg/builtin/#error">error</a></pre>
<p>
VerifyResponses verifies the response this CoSi has against the aggregated
public key the tree is using. This is callable by any nodes in the tree,
after it has aggregated its responses. You can enforce verification at each
level of the tree for faster reactivity.
</p>

</div><!-- .container -->
</div><!-- #page -->
<!-- TODO(adonovan): load these from <head> using "defer" attribute? -->
<script src="../../../../.goduckstyle/jquery.js" type="text/javascript"></script>
<script src="../../../../.goduckstyle/jquery.treeview.js" type="text/javascript"></script>
<script src="../../../../.goduckstyle/jquery.treeview.edit.js" type="text/javascript"></script>
<script>var goVersion = "go1.7.1";</script>
<script src="../../../../.goduckstyle/godocs.js" type="text/javascript"></script>
</body>
</html>
