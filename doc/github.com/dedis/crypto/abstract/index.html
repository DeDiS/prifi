<!DOCTYPE html>

<html>
<head>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type">
<meta content="width=device-width, initial-scale=1" name="viewport">
<meta content="#375EAB" name="theme-color">
<title>abstract - The PriFi Project</title>
<link href="../../../../.goduckstyle/style.css" rel="stylesheet" type="text/css">
<link href="../../../../.goduckstyle/jquery.treeview.css" rel="stylesheet">
<script type="text/javascript">window.initFuncs = [];</script>
</link></link></meta></meta></meta></head>
<body>
<div id="lowframe" style="position: fixed; bottom: 0; left: 0; height: 0; width: 100%; border-top: thin solid grey; background-color: white; overflow: auto;">
...
</div><!-- #lowframe -->
<div class="wide" id="topbar"><div class="container">
<div class="top-heading" id="heading-wide">The PriFi Project</div>
<div class="top-heading" id="heading-narrow"><a href="/">Go</a></div>
<a href="#" id="menu-button"><span id="menu-button-arrow">▽</span></a>
<form action="/search" method="GET">
<div id="menu">





</div>
</form>
</div></div>
<div class="wide" id="page">
<div class="container">
<h1>Package abstract</h1>
<div id="nav"></div>
<!--
	Copyright 2009 The Go Authors. All rights reserved.
	Use of this source code is governed by a BSD-style
	license that can be found in the LICENSE file.
-->
<!--
	Note: Static (i.e., not template-generated) href and id
	attributes start with "pkg-" to make it impossible for
	them to conflict with generated attributes (some of which
	correspond to Go identifiers).
-->
<script type="text/javascript">
	document.ANALYSIS_DATA = null;
	document.CALLGRAPH = null;
	</script>
<div id="short-nav">
<dl>
<dd><code>import "github.com/dedis/crypto/abstract"</code></dd>
</dl>
<dl>
<dd><a class="overviewLink" href="#pkg-overview">Overview</a></dd>
<dd><a class="indexLink" href="#pkg-index">Index</a></dd>
</dl>
</div>
<!-- The package's Name is printed as title by the top-level template -->
<div class="toggleVisible" id="pkg-overview">
<div class="collapsed">
<h2 class="toggleButton" title="Click to show Overview section">Overview ▹</h2>
</div>
<div class="expanded">
<h2 class="toggleButton" title="Click to hide Overview section">Overview ▾</h2>
<p>
This package defines abstract interfaces for advanced cryptographic primitives.
Implementations of these interfaces are provided in other packages.
</p>
</div>
</div>
<div class="toggleVisible" id="pkg-index">
<div class="collapsed">
<h2 class="toggleButton" title="Click to show Index section">Index ▹</h2>
</div>
<div class="expanded">
<h2 class="toggleButton" title="Click to hide Index section">Index ▾</h2>
<!-- Table of contents for API; must be named manual-nav to turn off auto nav. -->
<div id="manual-nav">
<dl>
<dd><a href="#pkg-variables">Variables</a></dd>
<dd><a href="#SuiteNew">func SuiteNew(s Suite, t reflect.Type) interface{}</a></dd>
<dd><a href="#SuiteRead">func SuiteRead(s Suite, r io.Reader, objs ...interface{}) error</a></dd>
<dd><a href="#SuiteWrite">func SuiteWrite(s Suite, w io.Writer, objs ...interface{}) error</a></dd>
<dd><a href="#Sum">func Sum(suite Suite, data ...[]byte) []byte</a></dd>
<dd><a href="#BinaryEncoding">type BinaryEncoding</a></dd>
<dd>    <a href="#BinaryEncoding.Read">func (e BinaryEncoding) Read(r io.Reader, objs ...interface{}) error</a></dd>
<dd>    <a href="#BinaryEncoding.Write">func (e BinaryEncoding) Write(w io.Writer, objs ...interface{}) error</a></dd>
<dd><a href="#Cipher">type Cipher</a></dd>
<dd>    <a href="#Cipher.Clone">func (c Cipher) Clone() Cipher</a></dd>
<dd>    <a href="#Cipher.EndMessage">func (c Cipher) EndMessage()</a></dd>
<dd>    <a href="#Cipher.Message">func (c Cipher) Message(dst, src, key []byte) Cipher</a></dd>
<dd>    <a href="#Cipher.Open">func (c Cipher) Open(dst, src []byte) ([]byte, error)</a></dd>
<dd>    <a href="#Cipher.Partial">func (c Cipher) Partial(dst, src, key []byte) Cipher</a></dd>
<dd>    <a href="#Cipher.Read">func (c Cipher) Read(dst []byte) (n int, err error)</a></dd>
<dd>    <a href="#Cipher.Seal">func (c Cipher) Seal(dst, src []byte) []byte</a></dd>
<dd>    <a href="#Cipher.Sum">func (c Cipher) Sum(dst []byte) []byte</a></dd>
<dd>    <a href="#Cipher.Write">func (c Cipher) Write(key []byte) (n int, err error)</a></dd>
<dd>    <a href="#Cipher.XORKeyStream">func (c Cipher) XORKeyStream(dst, src []byte)</a></dd>
<dd><a href="#CipherState">type CipherState</a></dd>
<dd><a href="#Constructor">type Constructor</a></dd>
<dd><a href="#Encoding">type Encoding</a></dd>
<dd><a href="#Group">type Group</a></dd>
<dd><a href="#Hiding">type Hiding</a></dd>
<dd><a href="#Marshaling">type Marshaling</a></dd>
<dd><a href="#Point">type Point</a></dd>
<dd><a href="#Scalar">type Scalar</a></dd>
<dd><a href="#Suite">type Suite</a></dd>
</dl>
</div><!-- #manual-nav -->
<h4>Package files</h4>
<p>
<span style="font-size:90%">
<a href="/src/github.com/dedis/crypto/abstract/cipher.go">cipher.go</a>
<a href="/src/github.com/dedis/crypto/abstract/doc.go">doc.go</a>
<a href="/src/github.com/dedis/crypto/abstract/encoding.go">encoding.go</a>
<a href="/src/github.com/dedis/crypto/abstract/group.go">group.go</a>
<a href="/src/github.com/dedis/crypto/abstract/sponge.go">sponge.go</a>
<a href="/src/github.com/dedis/crypto/abstract/suite.go">suite.go</a>
</span>
</p>
</div><!-- .expanded -->
</div><!-- #pkg-index -->
<div class="toggle" id="pkg-callgraph" style="display: none">
<div class="collapsed">
<h2 class="toggleButton" title="Click to show Internal Call Graph section">Internal call graph ▹</h2>
</div> <!-- .expanded -->
<div class="expanded">
<h2 class="toggleButton" title="Click to hide Internal Call Graph section">Internal call graph ▾</h2>
<p>
			  In the call graph viewer below, each node
			  is a function belonging to this package
			  and its children are the functions it
			  calls—perhaps dynamically.
			</p>
<p>
			  The root nodes are the entry points of the
			  package: functions that may be called from
			  outside the package.
			  There may be non-exported or anonymous
			  functions among them if they are called
			  dynamically from another package.
			</p>
<p>
			  Click a node to visit that function's source code.
			  From there you can visit its callers by
			  clicking its declaring <code>func</code>
			  token.
			</p>
<p>
			  Functions may be omitted if they were
			  determined to be unreachable in the
			  particular programs or tests that were
			  analyzed.
			</p>
<!-- Zero means show all package entry points. -->
<ul class="treeview" id="callgraph-0" style="margin-left: 0.5in"></ul>
</div>
</div> <!-- #pkg-callgraph -->
<h2 id="pkg-variables">Variables</h2>
<pre>var <span id="NoKey">NoKey</span> = []<a href="https://golang.org/pkg/builtin/#byte">byte</a>{}</pre>
<p>
Pass NoKey to a Cipher constructor to create an unkeyed Cipher.
</p>
<pre>var <span id="RandomKey">RandomKey</span> []<a href="https://golang.org/pkg/builtin/#byte">byte</a> = <a href="https://golang.org/pkg/builtin/#nil">nil</a></pre>
<p>
Pass RandomKey to a Cipher constructor to create a randomly seeded Cipher.
</p>
<h2 id="SuiteNew">func <a href="/src/github.com/dedis/crypto/abstract/encoding.go?s=9206:9256#L308">SuiteNew</a>
<a class="permalink" href="#SuiteNew">¶</a>
</h2>
<pre>func SuiteNew(s <a href="#Suite">Suite</a>, t <a href="../../../../reflect/index.html">reflect</a>.<a href="../../../../reflect/index.html#Type">Type</a>) interface{}</pre>
<p>
Default implementation of reflective constructor for ciphersuites
</p>
<h2 id="SuiteRead">func <a href="/src/github.com/dedis/crypto/abstract/encoding.go?s=9427:9490#L319">SuiteRead</a>
<a class="permalink" href="#SuiteRead">¶</a>
</h2>
<pre>func SuiteRead(s <a href="#Suite">Suite</a>, r <a href="../../../../io/index.html">io</a>.<a href="../../../../io/index.html#Reader">Reader</a>, objs ...interface{}) <a href="https://golang.org/pkg/builtin/#error">error</a></pre>
<p>
Default implementation of Encoding interface Read for ciphersuites
</p>
<h2 id="SuiteWrite">func <a href="/src/github.com/dedis/crypto/abstract/encoding.go?s=9620:9684#L324">SuiteWrite</a>
<a class="permalink" href="#SuiteWrite">¶</a>
</h2>
<pre>func SuiteWrite(s <a href="#Suite">Suite</a>, w <a href="../../../../io/index.html">io</a>.<a href="../../../../io/index.html#Writer">Writer</a>, objs ...interface{}) <a href="https://golang.org/pkg/builtin/#error">error</a></pre>
<p>
Default implementation of Encoding interface Write for ciphersuites
</p>
<h2 id="Sum">func <a href="/src/github.com/dedis/crypto/abstract/suite.go?s=1766:1810#L40">Sum</a>
<a class="permalink" href="#Sum">¶</a>
</h2>
<pre>func Sum(suite <a href="#Suite">Suite</a>, data ...[]<a href="https://golang.org/pkg/builtin/#byte">byte</a>) []<a href="https://golang.org/pkg/builtin/#byte">byte</a></pre>
<p>
Sum uses a given ciphersuite's hash function to checksum a byte-slice.
</p>
<h2 id="BinaryEncoding">type <a href="/src/github.com/dedis/crypto/abstract/encoding.go?s=4563:4799#L118">BinaryEncoding</a>
<a class="permalink" href="#BinaryEncoding">¶</a>
</h2>
<pre>type BinaryEncoding struct {
    <a href="#Constructor">Constructor</a> <span class="comment">// Constructor for instantiating abstract types</span>
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
<p>
BinaryEncoding represents a simple binary encoding
suitable for reading and writing fixed-length cryptographic objects.
The interface allows reading and writing composite types
such as structs, arrays, and slices,
but the encoded size of any object must be completely defined
by the type and size of the object itself and the ciphersuite in use.
</p>
<p>
Slices must be instantiated to the correct length
before either reading or writing:
hence the reader must determine the correct length "out of band"
(the encoding supports no transmission of length metadata).
</p>
<p>
XXX move this and Constructor to some other, more generic package
</p>
<h3 id="BinaryEncoding.Read">func (BinaryEncoding) <a href="/src/github.com/dedis/crypto/abstract/encoding.go?s=5132:5200#L140">Read</a>
<a class="permalink" href="#BinaryEncoding.Read">¶</a>
</h3>
<pre>func (e <a href="#BinaryEncoding">BinaryEncoding</a>) Read(r <a href="../../../../io/index.html">io</a>.<a href="../../../../io/index.html#Reader">Reader</a>, objs ...interface{}) <a href="https://golang.org/pkg/builtin/#error">error</a></pre>
<p>
Read a series of binary objects from an io.Reader.
The objs must be a list of pointers.
</p>
<h3 id="BinaryEncoding.Write">func (BinaryEncoding) <a href="/src/github.com/dedis/crypto/abstract/encoding.go?s=7680:7749#L242">Write</a>
<a class="permalink" href="#BinaryEncoding.Write">¶</a>
</h3>
<pre>func (e <a href="#BinaryEncoding">BinaryEncoding</a>) Write(w <a href="../../../../io/index.html">io</a>.<a href="../../../../io/index.html#Writer">Writer</a>, objs ...interface{}) <a href="https://golang.org/pkg/builtin/#error">error</a></pre>
<p>
Write a data structure containing cryptographic objects,
using their built-in binary serialization, to an io.Writer.
Supports writing of Points, Scalars,
basic fixed-length data types supported by encoding/binary/Write(),
and structs, arrays, and slices containing all of these types.
</p>
<p>
XXX should this perhaps become a Suite method?
</p>
<p>
XXX now this code could/should be moved into a separate package
relatively independent from this crypto code.
</p>
<h2 id="Cipher">type <a href="/src/github.com/dedis/crypto/abstract/cipher.go?s=7712:7791#L161">Cipher</a>
<a class="permalink" href="#Cipher">¶</a>
</h2>
<pre>type Cipher struct {
    <a href="#CipherState">CipherState</a> <span class="comment">// underlying message cipher implementation</span>
}</pre>
<p>
Cipher represents a general-purpose symmetric message cipher.
A Cipher instance embodies a scalar that may be used to encrypt/decrypt data
as well as to generate cryptographically random bits.
The Cipher can also cryptographically absorb data or key material,
updating its state to produce cryptographic hashes and authenticators.
Using these encryption and absorption functions in combination,
a Cipher may be used for authenticated encryption and decryption.
</p>
<p>
A Cipher is in fact simply a convenience/helper wrapper around
the CipherState interface, which represents and abstracts over
an underlying message cipher implementation.
The underlying CipherState instance typically embodies
both the specific message cipher algorithm in use,
and the choice of security parameter with which the cipher is operated.
This algorithm and security parameter is typically set
when the Cipher (and its underlying CipherState) instance is constructed.
The simplest way to get a Cipher instance is via a cipher Suite.
</p>
<p>
The standard function signature for a Cipher constructor is:
</p>
<pre>NewCipher(key []byte, options ...interface{}) Cipher
</pre>
<p>
If key is nil, the Cipher constructor picks a fresh, random key.
The key may be an empty but non-nil slice to create an unkeyed cipher.
Key material may be of any length, but to ensure full security,
secret keys should be at least the size returned by the KeySize method.
The variable-length options argument may contain options
whose interpretation is specific to the particular cipher.
(XXX may reconsider the wisdom of this options convention;
its lack of type-checking has led to accidental confusion at least once.)
</p>
<h3 id="Cipher.Clone">func (Cipher) <a href="/src/github.com/dedis/crypto/abstract/cipher.go?s=15254:15284#L353">Clone</a>
<a class="permalink" href="#Cipher.Clone">¶</a>
</h3>
<pre>func (c <a href="#Cipher">Cipher</a>) Clone() <a href="#Cipher">Cipher</a></pre>
<p>
Clone creates an initially identicial instance of a Cipher.
Warning:: misuse of Clone can lead to replay or key-reuse vulnerabilities.
</p>
<h3 id="Cipher.EndMessage">func (Cipher) <a href="/src/github.com/dedis/crypto/abstract/cipher.go?s=11492:11520#L249">EndMessage</a>
<a class="permalink" href="#Cipher.EndMessage">¶</a>
</h3>
<pre>func (c <a href="#Cipher">Cipher</a>) EndMessage()</pre>
<p>
EndMessage inserts an explicit end-of-message boundary,
finalizing the message currently being processed and starting a new one.
The client should typically call EndMessage after a series of
calls to streaming methods such as Partial, Read, or Write.
</p>
<h3 id="Cipher.Message">func (Cipher) <a href="/src/github.com/dedis/crypto/abstract/cipher.go?s=9076:9128#L190">Message</a>
<a class="permalink" href="#Cipher.Message">¶</a>
</h3>
<pre>func (c <a href="#Cipher">Cipher</a>) Message(dst, src, key []<a href="https://golang.org/pkg/builtin/#byte">byte</a>) <a href="#Cipher">Cipher</a></pre>
<p>
Message processes a complete message through the Cipher,
XORing a src byte-slice with cryptographic random bits to yield dst bytes,
and concurrently absorbing bytes from a key byte-slice into its state:
</p>
<pre>cipher.Message(dst, src, key) Cipher
</pre>
<p>
A call always processes exactly max(len(dst),len(dst),len(key)) bytes.
All slice arguments may be nil or of varying lengths.
If the src or key slices are short, the missing bytes are taken to be zero.
If the dst slice is short, the extra output bytes are discarded.
The src and/or key slices may overlap with dst exactly or not at all.
</p>
<p>
The Cipher preserves and cryptographically accounts for message boundaries,
so that the following sequence of two calls yields a result
that is always cryptographically distinct from the above single call.
</p>
<pre>cipher.Message(dst[:div], src[:div], key[:div])
cipher.Message(dst[div:], src[div:], key[div:])
</pre>
<p>
The Cipher guarantees that any key material absorbed during a given call
will cryptographically affect every bit of all future messages processed,
but makes no guarantees about whether key material absorbed in this call
will affect some, all, or none of the cryptographic pseudorandom bits
produced concurrently in the same call.
</p>
<h3 id="Cipher.Open">func (Cipher) <a href="/src/github.com/dedis/crypto/abstract/cipher.go?s=14274:14327#L318">Open</a>
<a class="permalink" href="#Cipher.Open">¶</a>
</h3>
<pre>func (c <a href="#Cipher">Cipher</a>) Open(dst, src []<a href="https://golang.org/pkg/builtin/#byte">byte</a>) ([]<a href="https://golang.org/pkg/builtin/#byte">byte</a>, <a href="https://golang.org/pkg/builtin/#error">error</a>)</pre>
<p>
Open decrypts and authenticates a message encrypted using Seal.
It decrypts sealed message src and appends it onto plaintext buffer dst,
growing the dst buffer if it is too small (or nil),
and returns the resulting destination buffer or an error.
</p>
<h3 id="Cipher.Partial">func (Cipher) <a href="/src/github.com/dedis/crypto/abstract/cipher.go?s=9996:10048#L213">Partial</a>
<a class="permalink" href="#Cipher.Partial">¶</a>
</h3>
<pre>func (c <a href="#Cipher">Cipher</a>) Partial(dst, src, key []<a href="https://golang.org/pkg/builtin/#byte">byte</a>) <a href="#Cipher">Cipher</a></pre>
<p>
Partial processes a partial (initial or continuing) portion of a message,
allowing the Cipher to be used for byte-granularity streaming:
</p>
<pre>cipher.Partial(dst, src, key)
</pre>
<p>
The above single call is thus equivalent to the following pair of calls:
</p>
<pre>cipher.Partial(dst[:div], src[:div], key[:div])
cipher.Partial(dst[div:], src[div:], key[div:])
</pre>
<p>
One or more calls to Partial must be terminated with a call to Message,
to complete the message and ensure that key-material bytes absorbed
in the current message affect the pseudorandom bits the Cipher produces
in the context of the next message.
Key material absorbed in a given Partial call may, or may not,
affect the pseudorandom bits generated in subsequent Partial calls
if there are no intervening calls to Message.
</p>
<h3 id="Cipher.Read">func (Cipher) <a href="/src/github.com/dedis/crypto/abstract/cipher.go?s=10395:10446#L224">Read</a>
<a class="permalink" href="#Cipher.Read">¶</a>
</h3>
<pre>func (c <a href="#Cipher">Cipher</a>) Read(dst []<a href="https://golang.org/pkg/builtin/#byte">byte</a>) (n <a href="https://golang.org/pkg/builtin/#int">int</a>, err <a href="https://golang.org/pkg/builtin/#error">error</a>)</pre>
<p>
Read satisfies the standard io.Reader interface,
yielding a stream of cryptographically pseudorandom bytes.
Consistent with the streaming semantics of the io.Reader interface,
two consecutive reads of length l1 and l2 produce the same bytes
as a single read of length l1+l2.
</p>
<h3 id="Cipher.Seal">func (Cipher) <a href="/src/github.com/dedis/crypto/abstract/cipher.go?s=13715:13759#L299">Seal</a>
<a class="permalink" href="#Cipher.Seal">¶</a>
</h3>
<pre>func (c <a href="#Cipher">Cipher</a>) Seal(dst, src []<a href="https://golang.org/pkg/builtin/#byte">byte</a>) []<a href="https://golang.org/pkg/builtin/#byte">byte</a></pre>
<p>
Seal uses a stateful message cipher to implement authenticated encryption.
It encrypts the src message and appends it to the dst slice,
growing or allocating the dst slice if it is too small or nil.
Seal also absorbs the produced ciphertext into the Cipher's state,
then uses that state to append a message authentication check (MAC)
to the sealed message, to be verified by Open.
</p>
<h3 id="Cipher.Sum">func (Cipher) <a href="/src/github.com/dedis/crypto/abstract/cipher.go?s=13090:13128#L282">Sum</a>
<a class="permalink" href="#Cipher.Sum">¶</a>
</h3>
<pre>func (c <a href="#Cipher">Cipher</a>) Sum(dst []<a href="https://golang.org/pkg/builtin/#byte">byte</a>) []<a href="https://golang.org/pkg/builtin/#byte">byte</a></pre>
<p>
Sum ends the current message and produces a cryptographic checksum or hash
based on the Cipher's state after absorbing all previously-written data.
The resulting hash is appended to the dst slice,
which Sum will grow or allocate if dst is too small or nil.
A Cipher may be used as a hash function by absorbing data via Write
and then calling Sum to finalize the message and produce the hash.
Unlike the hash.Hash interface, this Sum method affects the Cipher's state:
two consecutive calls to Sum on the same Cipher
will produce two different hashes, not the same one.
</p>
<h3 id="Cipher.Write">func (Cipher) <a href="/src/github.com/dedis/crypto/abstract/cipher.go?s=11108:11160#L239">Write</a>
<a class="permalink" href="#Cipher.Write">¶</a>
</h3>
<pre>func (c <a href="#Cipher">Cipher</a>) Write(key []<a href="https://golang.org/pkg/builtin/#byte">byte</a>) (n <a href="https://golang.org/pkg/builtin/#int">int</a>, err <a href="https://golang.org/pkg/builtin/#error">error</a>)</pre>
<p>
Write satisifies the standard io.Writer interface,
cryptographically absorbing all written data into the Cipher's state.
Consistent with the streaming semantics of the io.Writer interface,
Write calls by themselves never produce message boundaries,
and written data is NOT guaranteed to affect the Cipher's output
until the next explicit message boundary.
The caller should invoke EndMessage after a series of Write calls
to ensure that all written data is fully absorbed into the Cipher,
before reading Cipher output that is supposed to depend on the written data.
</p>
<h3 id="Cipher.XORKeyStream">func (Cipher) <a href="/src/github.com/dedis/crypto/abstract/cipher.go?s=12391:12436#L268">XORKeyStream</a>
<a class="permalink" href="#Cipher.XORKeyStream">¶</a>
</h3>
<pre>func (c <a href="#Cipher">Cipher</a>) XORKeyStream(dst, src []<a href="https://golang.org/pkg/builtin/#byte">byte</a>)</pre>
<p>
XORKeyStream satisfies the Go library's legacy cipher.Stream interface,
enabling a Cipher to be used as a stream cipher.
This method reads len(src) pseudorandom bytes from the Cipher,
XORs them with the corresponding bytes from src,
and writes the resulting stream-encrypted bytes to dst.
The dst slice must be at least as long as src,
and if it is longer, only the corresponding prefix of dst is affected.
</p>
<p>
Warning: stream ciphers inherently provide no authentication,
and malicious bit-flipping attacks are trivial if the encrypted stream
is not authenticated in some other way.
For this reason, stream cipher operation is not recommended
in common-case situations in which authenticated encryption methods
(e.g., via Seal and Open) are applicable.
</p>
<h2 id="CipherState">type <a href="/src/github.com/dedis/crypto/abstract/cipher.go?s=4873:5650#L96">CipherState</a>
<a class="permalink" href="#CipherState">¶</a>
</h2>
<pre>type CipherState interface {

    <span class="comment">// Transform a message (or the final portion of one) from src to dst,</span>
    <span class="comment">// absorb key into the cipher state, and return the Cipher.</span>
    Message(dst, src, key []<a href="https://golang.org/pkg/builtin/#byte">byte</a>)

    <span class="comment">// Transform a partial, incomplete message from src to dst,</span>
    <span class="comment">// absorb key into the cipher state, and return the Cipher.</span>
    Partial(dst, src, key []<a href="https://golang.org/pkg/builtin/#byte">byte</a>)

    <span class="comment">// Return the minimum size in bytes of secret keys for full security</span>
    <span class="comment">// (although key material may be of any size).</span>
    KeySize() <a href="https://golang.org/pkg/builtin/#int">int</a>

    <span class="comment">// Return recommended size in bytes of hashes for full security.</span>
    <span class="comment">// This is usually 2*KeySize() to account for birthday attacks.</span>
    HashSize() <a href="https://golang.org/pkg/builtin/#int">int</a>

    <span class="comment">// Create an identical clone of this cryptographic state object.</span>
    <span class="comment">// Caution: misuse can lead to key-reuse vulnerabilities.</span>
    Clone() <a href="#CipherState">CipherState</a>
}</pre>
<p>
CipherState defines an interface to an abstract symmetric message cipher.
The cipher embodies a scalar that may be used to encrypt/decrypt data
as well as to generate cryptographically random bits.
The Cipher can also cryptographically absorb data or key material,
updating its state to produce cryptographic hashes and authenticators.
</p>
<p>
The main Message method processes a complete message through the Cipher,
XORing a src byte-slice with cryptographic random bits to yield dst bytes,
and concurrently absorbing bytes from a key byte-slice into its state:
</p>
<pre>cipher.Message(dst, src, key) Cipher
</pre>
<p>
A call always processes exactly max(len(dst),len(dst),len(key)) bytes.
All slice arguments may be nil or of varying lengths.
If the src or key slices are short, the missing bytes are taken to be zero.
If the dst slice is short, the extra output bytes are discarded.
The src and/or key slices may overlap with dst exactly or not at all.
</p>
<p>
The cipher preserves and cryptographically accounts for message boundaries,
so that the following sequence of two calls yields a result
that is always cryptographically distinct from the above single call.
</p>
<pre>cipher.Message(dst[:div], src[:div], key[:div])
cipher.Message(dst[div:], src[div:], key[div:])
</pre>
<p>
The cipher guarantees that any key material absorbed during a given call
will cryptographically affect every bit of all future messages processed,
but makes no guarantees about whether key material absorbed in this call
will affect some, all, or none of the cryptographic pseudorandom bits
produced concurrently in the same call.
</p>
<p>
A message cipher supports "full-duplex" operation,
concurrently producing pseudorandom bits and absorbing data,
supporting efficient use for authenticated encryption.
This sequence of calls encrypts a plaintext msg to produce a ciphertext ctx
and an associated message-authenticator mac:
</p>
<pre>cipher.Message(ctx, msg, ctx)	// Encrypt and absorb ciphertext
cipher.Message(mac, nil, nil)	// Produce MAC based on ciphertext
</pre>
<p>
This encrypts msg into ctx by XORing it with bits generated by the cipher,
while absorbing the output ciphertext into the cipher's state.
The second Message call then uses the resulting state to produce a MAC.
</p>
<p>
The following sequence decrypts and verifies a received ciphertext and MAC
encrypted in the above fashion:
</p>
<pre>cipher.Message(msg, ctx, ctx)	// Decrypt and absorb ciphertext
cipher.Message(mac, mac, nil)	// Compute MAC and XOR with received
valid := subtle.ConstantTimeAllEq(mac, 0)
</pre>
<p>
This decrypts ctx into msg by XORing the same bits used during encryption,
while similarly absorbing the ciphertext (which is the input this time).
The second Message call recomputes the MAC based on the absorbed ciphertext,
XORs the recomputed MAC onto the received MAC in-place,
and verifies in constant time that the result is zero
(i.e., that the received and recomputed MACs are equal).
</p>
<p>
The Cipher wrapper provides convenient Seal and Open functions
performing the above authenticated encryption sequences.
</p>
<p>
A cipher may be operated as a cryptographic hash function taking
messsage msg and producing cryptographic checksum in slice sum:
</p>
<pre>cipher.Message(nil, nil, msg)	// Absorb msg into Cipher state
cipher.Message(sum, nil, nil)	// Produce cryptographic hash in sum
</pre>
<p>
Both the input msg and output sum may be of any length,
and the Cipher guarantees that every bit of the output sum has a
strong cryptographic dependency on every bit of the input msg.
However, to achieve full security, the caller should ensure that
the output sum is at least cipher.HashSize() bytes long.
</p>
<p>
The Partial method processes a partial (initial or continuing) portion
of a message, allowing the Cipher to be used for byte-granularity streaming:
</p>
<pre>cipher.Partial(dst, src, key)
</pre>
<p>
The above single call is thus equivalent to the following pair of calls:
</p>
<pre>cipher.Partial(dst[:div], src[:div], key[:div])
cipher.Partial(dst[div:], src[div:], key[div:])
</pre>
<p>
One or more calls to Partial must be terminated with a call to Message,
to complete the message and ensure that key-material bytes absorbed
in the current message affect the pseudorandom bits the Cipher produces
in the context of the next message.
Key material absorbed in a given Partial call may, or may not,
affect the pseudorandom bits generated in subsequent Partial calls
if there are no intervening calls to Message.
</p>
<p>
A Cipher may be used to generate pseudorandom bits that depend
only on the Cipher's initial state in the following fashion:
</p>
<pre>cipher.Partial(dst, nil, nil)
</pre>
<h2 id="Constructor">type <a href="/src/github.com/dedis/crypto/abstract/encoding.go?s=3835:3898#L100">Constructor</a>
<a class="permalink" href="#Constructor">¶</a>
</h2>
<pre>type Constructor interface {
    New(t <a href="../../../../reflect/index.html">reflect</a>.<a href="../../../../reflect/index.html#Type">Type</a>) interface{}
}</pre>
<p>
Constructor represents a generic constructor
that takes a reflect.Type, typically for an interface type,
and constructs some suitable concrete instance of that type.
The crypto library uses this capability to support
dynamic instantiation of cryptographic objects of the concrete type
appropriate for a given abstract.Suite.
</p>
<h2 id="Encoding">type <a href="/src/github.com/dedis/crypto/abstract/encoding.go?s=3103:3318#L78">Encoding</a>
<a class="permalink" href="#Encoding">¶</a>
</h2>
<pre>type Encoding interface {

    <span class="comment">// Encode and write objects to an io.Writer.</span>
    Write(w <a href="../../../../io/index.html">io</a>.<a href="../../../../io/index.html#Writer">Writer</a>, objs ...interface{}) <a href="https://golang.org/pkg/builtin/#error">error</a>

    <span class="comment">// Read and decode objects from an io.Reader.</span>
    Read(r <a href="../../../../io/index.html">io</a>.<a href="../../../../io/index.html#Reader">Reader</a>, objs ...interface{}) <a href="https://golang.org/pkg/builtin/#error">error</a>
}</pre>
<p>
Encoding represents an abstract interface to an encoding/decoding
that can be used to marshal/unmarshal objects to and from streams.
Different Encodings will have different constraints, of course.
</p>
<h2 id="Group">type <a href="/src/github.com/dedis/crypto/abstract/group.go?s=4665:4935#L140">Group</a>
<a class="permalink" href="#Group">¶</a>
</h2>
<pre>type Group interface {
    String() <a href="https://golang.org/pkg/builtin/#string">string</a>

    ScalarLen() <a href="https://golang.org/pkg/builtin/#int">int</a> <span class="comment">// Max len of scalars in bytes</span>
    Scalar() <a href="#Scalar">Scalar</a> <span class="comment">// Create new scalar</span>

    PointLen() <a href="https://golang.org/pkg/builtin/#int">int</a> <span class="comment">// Max len of point in bytes</span>
    Point() <a href="#Point">Point</a>  <span class="comment">// Create new point</span>

    PrimeOrder() <a href="https://golang.org/pkg/builtin/#bool">bool</a> <span class="comment">// Returns true if group is prime-order</span>
}</pre>
<p>
This interface represents an abstract cryptographic group
usable for Diffie-Hellman key exchange, ElGamal encryption,
and the related body of public-key cryptographic algorithms
and zero-knowledge proof methods.
The Group interface is designed in particular to be a generic front-end
to both traditional DSA-style modular arithmetic groups
and ECDSA-style elliptic curves:
the caller of this interface's methods
need not know or care which specific mathematical construction
underlies the interface.
</p>
<p>
The Group interface is essentially just a "constructor" interface
enabling the caller to generate the two particular types of objects
relevant to DSA-style public-key cryptography;
we call these objects Points and Scalars.
The caller must explicitly initialize or set a new Point or Scalar object
to some value before using it as an input to some other operation
involving Point and/or Scalar objects.
For example, to compare a point P against the neutral (identity) element,
you might use P.Equal(suite.Point().Null()),
but not just P.Equal(suite.Point()).
</p>
<p>
It is expected that any implementation of this interface
should satisfy suitable hardness assumptions for the applicable group:
e.g., that it is cryptographically hard for an adversary to
take an encrypted Point and the known generator it was based on,
and derive the Scalar with which the Point was encrypted.
Any implementation is also expected to satisfy
the standard homomorphism properties that Diffie-Hellman
and the associated body of public-key cryptography are based on.
</p>
<p>
XXX should probably delete the somewhat redundant ...Len() methods.
</p>
<h2 id="Hiding">type <a href="/src/github.com/dedis/crypto/abstract/encoding.go?s=2022:2895#L52">Hiding</a>
<a class="permalink" href="#Hiding">¶</a>
</h2>
<pre>type Hiding interface {

    <span class="comment">// Hiding-encoded length of this object in bytes.</span>
    HideLen() <a href="https://golang.org/pkg/builtin/#int">int</a>

    <span class="comment">// Attempt to encode the content of this object into a slice,</span>
    <span class="comment">// whose length must be exactly HideLen(),</span>
    <span class="comment">// using a specified source of random bits.</span>
    <span class="comment">// Encoding may consistently fail on some curve points,</span>
    <span class="comment">// in which case this method returns nil,</span>
    <span class="comment">// and the caller must try again after re-randomizing the object.</span>
    HideEncode(rand <a href="../../../../crypto/cipher/index.html">cipher</a>.<a href="../../../../crypto/cipher/index.html#Stream">Stream</a>) []<a href="https://golang.org/pkg/builtin/#byte">byte</a>

    <span class="comment">// Decode a uniform representation of this object from a slice,</span>
    <span class="comment">// whose length must be exactly HideLen().</span>
    <span class="comment">// This method cannot fail on correctly-sized input:</span>
    <span class="comment">// it maps every HideLen()-byte string to some object.</span>
    <span class="comment">// This is a necessary security property,</span>
    <span class="comment">// since if some correctly-sized byte strings failed to decode,</span>
    <span class="comment">// an attacker could use decoding as a hidden object detection test.</span>
    HideDecode(buf []<a href="https://golang.org/pkg/builtin/#byte">byte</a>)
}</pre>
<p>
Hiding is an alternative encoding interface to encode cryptographic objects
such that their representation appears indistinguishable from a
uniformly random byte-string.
</p>
<p>
Achieving uniformity in representation is challenging for elliptic curves.
For this reason, the Hiding-encoding of an elliptic curve point
is typically more costly to compute than the normal (non-hidden) encoding,
may be less space efficient,
and may not allow representation for all possible curve points.
This interface allows the ciphersuite to determine
the specific uniform encoding method and balance their tradeoffs.
Since some uniform encodings cannot represent all possible points,
the caller must be prepared to call HideEncode() in a loop
with a freshly-chosen object (typically a fresh Diffie-Hellman public key).
</p>
<p>
For further background and technical details:
</p>
<pre>"Elligator: Elliptic-curve points indistinguishable from uniform random strings"
<a href="http://elligator.cr.yp.to/elligator-20130828.pdf">http://elligator.cr.yp.to/elligator-20130828.pdf</a>
"Elligator Squared: Uniform Points on Elliptic Curves of Prime Order as Uniform Random Strings"
<a href="http://eprint.iacr.org/2014/043.pdf">http://eprint.iacr.org/2014/043.pdf</a>
"Binary Elligator squared"
<a href="http://eprint.iacr.org/2014/486.pdf">http://eprint.iacr.org/2014/486.pdf</a>
</pre>
<h2 id="Marshaling">type <a href="/src/github.com/dedis/crypto/abstract/encoding.go?s=276:838#L8">Marshaling</a>
<a class="permalink" href="#Marshaling">¶</a>
</h2>
<pre>type Marshaling interface {
    <a href="../../../../encoding/index.html">encoding</a>.<a href="../../../../encoding/index.html#BinaryMarshaler">BinaryMarshaler</a>
    <a href="../../../../encoding/index.html">encoding</a>.<a href="../../../../encoding/index.html#BinaryUnmarshaler">BinaryUnmarshaler</a>

    <span class="comment">// XXX This may go away from the interface.</span>
    String() <a href="https://golang.org/pkg/builtin/#string">string</a>

    <span class="comment">// Encoded length of this object in bytes.</span>
    MarshalSize() <a href="https://golang.org/pkg/builtin/#int">int</a>

    <span class="comment">// Encode the contents of this object and write it to an io.Writer.</span>
    MarshalTo(w <a href="../../../../io/index.html">io</a>.<a href="../../../../io/index.html#Writer">Writer</a>) (<a href="https://golang.org/pkg/builtin/#int">int</a>, <a href="https://golang.org/pkg/builtin/#error">error</a>)

    <span class="comment">// Decode the content of this object by reading from an io.Reader.</span>
    <span class="comment">// If r is a Cipher, uses it to pick a valid object pseudo-randomly,</span>
    <span class="comment">// which may entail reading more than Len bytes due to retries.</span>
    UnmarshalFrom(r <a href="../../../../io/index.html">io</a>.<a href="../../../../io/index.html#Reader">Reader</a>) (<a href="https://golang.org/pkg/builtin/#int">int</a>, <a href="https://golang.org/pkg/builtin/#error">error</a>)
}</pre>
<p>
Marshaling is a basic interface representing fixed-length (or known-length)
cryptographic objects or structures having a built-in binary encoding.
</p>
<h2 id="Point">type <a href="/src/github.com/dedis/crypto/abstract/group.go?s=1690:3048#L60">Point</a>
<a class="permalink" href="#Point">¶</a>
</h2>
<pre>type Point interface {
    <a href="#Marshaling">Marshaling</a>

    <span class="comment">// Equality test for two Points derived from the same Group</span>
    Equal(s2 <a href="#Point">Point</a>) <a href="https://golang.org/pkg/builtin/#bool">bool</a>

    Null() <a href="#Point">Point</a> <span class="comment">// Set to neutral identity element</span>

    <span class="comment">// Set to this group's standard base point.</span>
    Base() <a href="#Point">Point</a>

    <span class="comment">// Pick and set to a point that is at least partly [pseudo-]random,</span>
    <span class="comment">// and optionally so as to encode a limited amount of specified data.</span>
    <span class="comment">// If data is nil, the point is completely [pseudo]-random.</span>
    <span class="comment">// Returns this Point and a slice containing the remaining data</span>
    <span class="comment">// following the data that was successfully embedded in this point.</span>
    Pick(data []<a href="https://golang.org/pkg/builtin/#byte">byte</a>, rand <a href="../../../../crypto/cipher/index.html">cipher</a>.<a href="../../../../crypto/cipher/index.html#Stream">Stream</a>) (<a href="#Point">Point</a>, []<a href="https://golang.org/pkg/builtin/#byte">byte</a>)

    <span class="comment">// Maximum number of bytes that can be reliably embedded</span>
    <span class="comment">// in a single group element via Pick().</span>
    PickLen() <a href="https://golang.org/pkg/builtin/#int">int</a>

    <span class="comment">// Set equal to another Point p.</span>
    Set(p <a href="#Point">Point</a>) <a href="#Point">Point</a>

    <span class="comment">// Clone clones the underlying point.</span>
    Clone() <a href="#Point">Point</a>

    <span class="comment">// Extract data embedded in a point chosen via Embed().</span>
    <span class="comment">// Returns an error if doesn't represent valid embedded data.</span>
    Data() ([]<a href="https://golang.org/pkg/builtin/#byte">byte</a>, <a href="https://golang.org/pkg/builtin/#error">error</a>)

    <span class="comment">// Add points so that their scalars add homomorphically</span>
    Add(a, b <a href="#Point">Point</a>) <a href="#Point">Point</a>

    <span class="comment">// Subtract points so that their scalars subtract homomorphically</span>
    Sub(a, b <a href="#Point">Point</a>) <a href="#Point">Point</a>

    <span class="comment">// Set to the negation of point a</span>
    Neg(a <a href="#Point">Point</a>) <a href="#Point">Point</a>

    <span class="comment">// Encrypt point p by multiplying with scalar s.</span>
    <span class="comment">// If p == nil, encrypt the standard base point Base().</span>
    Mul(p <a href="#Point">Point</a>, s <a href="#Scalar">Scalar</a>) <a href="#Point">Point</a>
}</pre>
<p>
A Point abstractly represents an element of a public-key cryptographic Group.
For example,
this is a number modulo the prime P in a DSA-style Schnorr group,
or an x,y point on an elliptic curve.
A Point can contain a Diffie-Hellman public key,
an ElGamal ciphertext, etc.
</p>
<h2 id="Scalar">type <a href="/src/github.com/dedis/crypto/abstract/group.go?s=331:1410#L4">Scalar</a>
<a class="permalink" href="#Scalar">¶</a>
</h2>
<pre>type Scalar interface {
    <a href="#Marshaling">Marshaling</a>

    <span class="comment">// Equality test for two Scalars derived from the same Group</span>
    Equal(s2 <a href="#Scalar">Scalar</a>) <a href="https://golang.org/pkg/builtin/#bool">bool</a>

    <span class="comment">// Set equal to another Scalar a</span>
    Set(a <a href="#Scalar">Scalar</a>) <a href="#Scalar">Scalar</a>

    <span class="comment">// Clone creates a new Scalar with same value</span>
    Clone() <a href="#Scalar">Scalar</a>

    <span class="comment">// Set to a small integer value</span>
    SetInt64(v <a href="https://golang.org/pkg/builtin/#int64">int64</a>) <a href="#Scalar">Scalar</a>

    <span class="comment">// Set to the additive identity (0)</span>
    Zero() <a href="#Scalar">Scalar</a>

    <span class="comment">// Set to the modular sum of scalars a and b</span>
    Add(a, b <a href="#Scalar">Scalar</a>) <a href="#Scalar">Scalar</a>

    <span class="comment">// Set to the modular difference a - b</span>
    Sub(a, b <a href="#Scalar">Scalar</a>) <a href="#Scalar">Scalar</a>

    <span class="comment">// Set to the modular negation of scalar a</span>
    Neg(a <a href="#Scalar">Scalar</a>) <a href="#Scalar">Scalar</a>

    <span class="comment">// Set to the multiplicative identity (1)</span>
    One() <a href="#Scalar">Scalar</a>

    <span class="comment">// Set to the modular product of scalars a and b</span>
    Mul(a, b <a href="#Scalar">Scalar</a>) <a href="#Scalar">Scalar</a>

    <span class="comment">// Set to the modular division of scalar a by scalar b</span>
    Div(a, b <a href="#Scalar">Scalar</a>) <a href="#Scalar">Scalar</a>

    <span class="comment">// Set to the modular inverse of scalar a</span>
    Inv(a <a href="#Scalar">Scalar</a>) <a href="#Scalar">Scalar</a>

    <span class="comment">// Set to a fresh random or pseudo-random scalar</span>
    Pick(rand <a href="../../../../crypto/cipher/index.html">cipher</a>.<a href="../../../../crypto/cipher/index.html#Stream">Stream</a>) <a href="#Scalar">Scalar</a>
    <span class="comment">// SetBytes will take bytes and create a scalar out of it</span>
    SetBytes([]<a href="https://golang.org/pkg/builtin/#byte">byte</a>) <a href="#Scalar">Scalar</a>

    <span class="comment">// Bytes returns the raw internal representation</span>
    Bytes() []<a href="https://golang.org/pkg/builtin/#byte">byte</a>
}</pre>
<p>
A Scalar abstractly represents a scalar value by which
a Point (group element) may be encrypted to produce another Point.
This is an exponent in DSA-style groups,
in which security is based on the Discrete Logarithm assumption,
and a scalar multiplier in elliptic curve groups.
</p>
<h2 id="Suite">type <a href="/src/github.com/dedis/crypto/abstract/suite.go?s=1010:1690#L15">Suite</a>
<a class="permalink" href="#Suite">¶</a>
</h2>
<pre>type Suite interface {

    <span class="comment">// Create a cryptographic Cipher with a given key and configuration.</span>
    <span class="comment">// If key is nil, creates a Cipher seeded with a fresh random key.</span>
    Cipher(key []<a href="https://golang.org/pkg/builtin/#byte">byte</a>, options ...interface{}) <a href="#Cipher">Cipher</a>

    <span class="comment">// Symmetric-key hash function</span>
    Hash() <a href="../../../../hash/index.html">hash</a>.<a href="../../../../hash/index.html#Hash">Hash</a>

    <span class="comment">// Abstract group for public-key crypto</span>
    <a href="#Group">Group</a>

    <span class="comment">// Fixed-length binary encoding for all crypto objects</span>
    <a href="#Encoding">Encoding</a>

    <span class="comment">// Generic constructor to instantiate any abstract interface type</span>
    <span class="comment">// supported by this suite: at least Cipher, Hash, Point, Scalar.</span>
    <a href="#Constructor">Constructor</a>

    <span class="comment">// NewKey returns a freshly generated private key from the cipher stream.</span>
    <span class="comment">// If cipher == nil, it uses random.Stream.</span>
    NewKey(<a href="../../../../crypto/cipher/index.html">cipher</a>.<a href="../../../../crypto/cipher/index.html#Stream">Stream</a>) <a href="#Scalar">Scalar</a>
}</pre>
<p>
Suite is an abstract interface to a full suite of
public-key and symmetric-key crypto primitives
chosen to be suited to each other and haver matching security parameters.
A ciphersuite in this framework basically consists of three components:
a hash function, a stream cipher, and an abstract group
for public-key crypto.
</p>
<p>
This interface adopts hashes and stream ciphers as its
fundamental symmetric-key crypto abstractions because
they are conceptually simple and directly complementary in function:
a hash takes any desired number of input bytes
and produces a small fixed number of output bytes,
whereas a stream cipher takes a small fixed number of input bytes
and produces any desired number of output bytes.
While stream ciphers can be and often are constructed from block ciphers,
we treat block ciphers as an implementation detail
hidden below the abstraction level of this ciphersuite interface.
</p>

</div><!-- .container -->
</div><!-- #page -->
<!-- TODO(adonovan): load these from <head> using "defer" attribute? -->
<script src="../../../../.goduckstyle/jquery.js" type="text/javascript"></script>
<script src="../../../../.goduckstyle/jquery.treeview.js" type="text/javascript"></script>
<script src="../../../../.goduckstyle/jquery.treeview.edit.js" type="text/javascript"></script>
<script>var goVersion = "go1.7.1";</script>
<script src="../../../../.goduckstyle/godocs.js" type="text/javascript"></script>
</body>
</html>
