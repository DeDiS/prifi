<!DOCTYPE html>

<html>
<head>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type">
<meta content="width=device-width, initial-scale=1" name="viewport">
<meta content="#375EAB" name="theme-color">
<title>crypto - The PriFi Project</title>
<link href="../../../.goduckstyle/style.css" rel="stylesheet" type="text/css">
<link href="../../../.goduckstyle/jquery.treeview.css" rel="stylesheet">
<script type="text/javascript">window.initFuncs = [];</script>
</link></link></meta></meta></meta></head>
<body>
<div id="lowframe" style="position: fixed; bottom: 0; left: 0; height: 0; width: 100%; border-top: thin solid grey; background-color: white; overflow: auto;">
...
</div><!-- #lowframe -->
<div class="wide" id="topbar"><div class="container">
<div class="top-heading" id="heading-wide">The PriFi Project</div>
<div class="top-heading" id="heading-narrow"><a href="/">Go</a></div>
<a href="#" id="menu-button"><span id="menu-button-arrow">▽</span></a>
<form action="/search" method="GET">
<div id="menu">





</div>
</form>
</div></div>
<div class="wide" id="page">
<div class="container">
<h1>Package crypto</h1>
<div id="nav"></div>
<!--
	Copyright 2009 The Go Authors. All rights reserved.
	Use of this source code is governed by a BSD-style
	license that can be found in the LICENSE file.
-->
<!--
	Note: Static (i.e., not template-generated) href and id
	attributes start with "pkg-" to make it impossible for
	them to conflict with generated attributes (some of which
	correspond to Go identifiers).
-->
<script type="text/javascript">
	document.ANALYSIS_DATA = null;
	document.CALLGRAPH = null;
	</script>
<div id="short-nav">
<dl>
<dd><code>import "github.com/dedis/crypto"</code></dd>
</dl>
<dl>
<dd><a class="overviewLink" href="#pkg-overview">Overview</a></dd>
<dd><a class="indexLink" href="#pkg-index">Index</a></dd>
<dd><a class="examplesLink" href="#pkg-examples">Examples</a></dd>
<dd><a href="#pkg-subdirectories">Subdirectories</a></dd>
</dl>
</div>
<!-- The package's Name is printed as title by the top-level template -->
<div class="toggleVisible" id="pkg-overview">
<div class="collapsed">
<h2 class="toggleButton" title="Click to show Overview section">Overview ▹</h2>
</div>
<div class="expanded">
<h2 class="toggleButton" title="Click to hide Overview section">Overview ▾</h2>
<p>
Package crypto provides a toolbox of advanced cryptographic primitives,
for applications that need more than straightforward signing and encryption.
The cornerstone of this toolbox is the 'abstract' sub-package,
which defines abstract interfaces to cryptographic primitives
designed to be independent of specific cryptographic algorithms,
to facilitate upgrading applications to new cryptographic algorithms
or switching to alternative algorithms for experimentation purposes.
</p>
<h3 id="hdr-Abstract_Groups_and_Crypto_Suites">Abstract Groups and Crypto Suites</h3>
<p>
This toolkit's public-key crypto API includes an abstract.Group interface
generically supporting a broad class of group-based public-key primitives
including DSA-style integer residue groups and elliptic curve groups.
Users of this API can thus write higher-level crypto algorithms
such as zero-knowledge proofs without knowing or caring
exactly what kind of group,
let alone which precise security parameters or elliptic curves,
are being used.
The abstract group interface supports the standard algebraic
operations on group elements and scalars that nontrivial
public-key algorithms tend to rely on.
The interface uses additive group terminology typical for elliptic curves,
such that point addition is homomorphically equivalent to
adding their (potentially secret) scalar multipliers.
But the API and its operations apply equally well to DSA-style integer groups.
</p>
<p>
The abstract.Suite interface builds further on the abstract.Group API
to represent an abstraction of entire pluggable ciphersuites,
which include a group (e.g., curve) suitable for advanced public-key crypto
together with a suitably matched set of symmetric-key crypto algorithms.
</p>
<p>
As a trivial example, generating a public/private keypair is as simple as:
</p>
<pre>a := suite.Scalar().Pick(random.Stream) // Alice's private key
A := suite.Point().Mul(nil, a)          // Alice's public key
</pre>
<p>
The first statement picks a private key (Scalar)
from a specified source of cryptographic random or pseudo-random bits,
while the second performs elliptic curve scalar multiplication
of the curve's standard base point (indicated by the 'nil' argument to Mul)
by the scalar private key 'a'.
Similarly, computing a Diffie-Hellman shared secret using
Alice's private key 'a' and Bob's public key 'B' can be done via:
</p>
<pre>S := suite.Point().Mul(B, a)		// Shared Diffie-Hellman secret
</pre>
<p>
Note that we use 'Mul' rather than 'Exp' here because the library
uses the additive-group terminology common for elliptic curve crypto,
rather than the multiplicative-group terminology of traditional integer groups -
but the two are semantically equivalent and
the interface itself works for both elliptic curve and integer groups.
See below for more complete examples.
</p>
<h3 id="hdr-Higher_level_Building_Blocks">Higher-level Building Blocks</h3>
<p>
Various sub-packages provide several specific
implementations of these abstract cryptographic interfaces.
In particular, the 'nist' sub-package provides implementations
of modular integer groups underlying conventional DSA-style algorithms,
and of NIST-standardized elliptic curves built on the Go crypto library.
The 'edwards' sub-package provides the abstract group interface
using more recent Edwards curves,
including the popular Ed25519 curve.
The 'openssl' sub-package offers an alternative implementation
of NIST-standardized elliptic curves and symmetric-key algorithms,
built as wrappers around OpenSSL's crypto library.
</p>
<p>
Other sub-packages build more interesting high-level cryptographic tools
atop these abstract primitive interfaces,
including:
</p>
<p>
- poly: Polynomial commitment and verifiable Shamir secret splitting
for implementing verifiable 't-of-n' threshold cryptographic schemes.
This can be used to encrypt a message so that any 2 out of 3 receivers
must work together to decrypt it, for example.
</p>
<p>
- proof: An implementation of the general Camenisch/Stadler framework
for discrete logarithm knowledge proofs.
This system supports both interactive and non-interactive proofs
of a wide variety of statements such as,
"I know the secret x associated with public key X
or I know the secret y associated with public key Y",
without revealing anything about either secret
or even which branch of the "or" clause is true.
</p>
<p>
- anon: Anonymous and pseudonymous public-key encryption and signing,
where the sender of a signed message or the receiver of an encrypted message
is defined as an explicit anonymity set containing several public keys
rather than just one.
For example, a member of an organization's board of trustees
might prove to be a member of the board without revealing which member she is.
</p>
<p>
- shuffle: Verifiable cryptographic shuffles of ElGamal ciphertexts,
which can be used to implement (for example) voting or auction schemes
that keep the sources of individual votes or bids private
without anyone having to trust the shuffler(s) to shuffle votes/bids honestly.
</p>
<h3 id="hdr-Disclaimer">Disclaimer</h3>
<p>
For now this library should currently be considered experimental:
it will definitely be changing in non-backward-compatible ways,
and it will need independent security review
before it should be considered ready for use in security-critical applications.
However, we intend to bring the library
closer to stability and real-world usability
as quickly as development resources permit,
and as interest and application demand dictates.
</p>
<p>
As should be obvious,
this library is intended the use of developers who are
at least moderately knowledgeable about crypto.
If you want a crypto library that makes it easy
to implement "basic crypto" functionality correctly -
i.e., plain public-key encryption and signing -
then the NaCl/Sodium pursues this worthy goal (<a href="http://doc.libsodium.org">http://doc.libsodium.org</a>).
This toolkit's purpose is to make it possible -
and preferably but not necessarily easy -
to do slightly more interesting things that most current crypto libraries
don't support effectively.
The one existing crypto library that this toolkit is probably most comparable to
is the Charm rapid prototyping library for Python (<a href="http://charm-crypto.com/">http://charm-crypto.com/</a>).
</p>
<p>
This library incorporates and/or builds on existing code
from a variety of sources,
as documented in the relevant sub-packages.
</p>
</div>
</div>
<div class="toggle" id="example__diffieHellman">
<div class="collapsed">
<p class="exampleHeading toggleButton">▹ <span class="text">Example (DiffieHellman)</span></p>
</div>
<div class="expanded">
<p class="exampleHeading toggleButton">▾ <span class="text">Example (DiffieHellman)</span></p>
<p>This example illustrates how to use the crypto toolkit's abstract group API
to perform basic Diffie-Hellman key exchange calculations,
using the NIST-standard P256 elliptic curve in this case.
Any other suitable elliptic curve or other cryptographic group may be used
simply by changing the first line that picks the suite.
</p>
<p>Code:</p>
<pre class="code"><span class="comment">// Crypto setup: NIST-standardized P256 curve with AES-128 and SHA-256</span>
suite := nist.NewAES128SHA256P256()

<span class="comment">// Alice's public/private keypair</span>
a := suite.Scalar().Pick(random.Stream) <span class="comment">// Alice's private key</span>
A := suite.Point().Mul(nil, a)          <span class="comment">// Alice's public key</span>

<span class="comment">// Bob's public/private keypair</span>
b := suite.Scalar().Pick(random.Stream) <span class="comment">// Alice's private key</span>
B := suite.Point().Mul(nil, b)          <span class="comment">// Alice's public key</span>

<span class="comment">// Assume Alice and Bob have securely obtained each other's public keys.</span>

<span class="comment">// Alice computes their shared secret using Bob's public key.</span>
SA := suite.Point().Mul(B, a)

<span class="comment">// Bob computes their shared secret using Alice's public key.</span>
SB := suite.Point().Mul(A, b)

<span class="comment">// They had better be the same!</span>
if !SA.Equal(SB) {
    panic("Diffie-Hellman key exchange didn't work")
}
println("Shared secret: " + SA.String())

<span class="comment"></span></pre>
</div>
</div>
<div class="toggle" id="example__elGamalEncryption">
<div class="collapsed">
<p class="exampleHeading toggleButton">▹ <span class="text">Example (ElGamalEncryption)</span></p>
</div>
<div class="expanded">
<p class="exampleHeading toggleButton">▾ <span class="text">Example (ElGamalEncryption)</span></p>
<p>This example illustrates how the crypto toolkit may be used
to perform "pure" ElGamal encryption,
in which the message to be encrypted is small enough to be embedded
directly within a group element (e.g., in an elliptic curve point).
For basic background on ElGamal encryption see for example
http://en.wikipedia.org/wiki/ElGamal_encryption.

Most public-key crypto libraries tend not to support embedding data in points,
in part because for "vanilla" public-key encryption you don't need it:
one would normally just generate an ephemeral Diffie-Hellman secret
and use that to seed a symmetric-key crypto algorithm such as AES,
which is much more efficient per bit and works for arbitrary-length messages.
However, in many advanced public-key crypto algorithms it is often useful
to be able to embedded data directly into points and compute with them:
as just one of many examples,
the proactively verifiable anonymous messaging scheme prototyped in Verdict
(see http://dedis.cs.yale.edu/dissent/papers/verdict-abs).

For fancier versions of ElGamal encryption implemented in this toolkit
see for example anon.Encrypt, which encrypts a message for
one of several possible receivers forming an explicit anonymity set.
</p>
<p>Code:</p>
<pre class="code">package crypto

import (
    "github.com/dedis/crypto/abstract"
    "github.com/dedis/crypto/nist"
    "github.com/dedis/crypto/random"
)

func ElGamalEncrypt(suite abstract.Suite, pubkey abstract.Point, message []byte) (
    K, C abstract.Point, remainder []byte) {

    <span class="comment">// Embed the message (or as much of it as will fit) into a curve point.</span>
    M, remainder := suite.Point().Pick(message, random.Stream)

    <span class="comment">// ElGamal-encrypt the point to produce ciphertext (K,C).</span>
    k := suite.Scalar().Pick(random.Stream) <span class="comment">// ephemeral private key</span>
    K = suite.Point().Mul(nil, k)           <span class="comment">// ephemeral DH public key</span>
    S := suite.Point().Mul(pubkey, k)       <span class="comment">// ephemeral DH shared secret</span>
    C = S.Add(S, M)                         <span class="comment">// message blinded with secret</span>
    return
}

func ElGamalDecrypt(suite abstract.Suite, prikey abstract.Scalar, K, C abstract.Point) (
    message []byte, err error) {

    <span class="comment">// ElGamal-decrypt the ciphertext (K,C) to reproduce the message.</span>
    S := suite.Point().Mul(K, prikey) <span class="comment">// regenerate shared secret</span>
    M := suite.Point().Sub(C, S)      <span class="comment">// use to un-blind the message</span>
    message, err = M.Data()           <span class="comment">// extract the embedded data</span>
    return
}

<span class="comment">/*
This example illustrates how the crypto toolkit may be used
to perform "pure" ElGamal encryption,
in which the message to be encrypted is small enough to be embedded
directly within a group element (e.g., in an elliptic curve point).
For basic background on ElGamal encryption see for example
http://en.wikipedia.org/wiki/ElGamal_encryption.

Most public-key crypto libraries tend not to support embedding data in points,
in part because for "vanilla" public-key encryption you don't need it:
one would normally just generate an ephemeral Diffie-Hellman secret
and use that to seed a symmetric-key crypto algorithm such as AES,
which is much more efficient per bit and works for arbitrary-length messages.
However, in many advanced public-key crypto algorithms it is often useful
to be able to embedded data directly into points and compute with them:
as just one of many examples,
the proactively verifiable anonymous messaging scheme prototyped in Verdict
(see http://dedis.cs.yale.edu/dissent/papers/verdict-abs).

For fancier versions of ElGamal encryption implemented in this toolkit
see for example anon.Encrypt, which encrypts a message for
one of several possible receivers forming an explicit anonymity set.
*/</span>
func Example_elGamalEncryption() {
    suite := nist.NewAES128SHA256P256()

    <span class="comment">// Create a public/private keypair</span>
    a := suite.Scalar().Pick(random.Stream) <span class="comment">// Alice's private key</span>
    A := suite.Point().Mul(nil, a)          <span class="comment">// Alice's public key</span>

    <span class="comment">// ElGamal-encrypt a message using the public key.</span>
    m := []byte("The quick brown fox")
    K, C, _ := ElGamalEncrypt(suite, A, m)

    <span class="comment">// Decrypt it using the corresponding private key.</span>
    mm, err := ElGamalDecrypt(suite, a, K, C)

    <span class="comment">// Make sure it worked!</span>
    if err != nil {
        panic("decryption failed: " + err.Error())
    }
    if string(mm) != string(m) {
        panic("decryption produced wrong output: " + string(mm))
    }
    println("Decryption succeeded: " + string(mm))

    <span class="comment">// Output:</span>
}
</pre>
</div>
</div>
<div class="toggleVisible" id="pkg-index">
<div class="collapsed">
<h2 class="toggleButton" title="Click to show Index section">Index ▹</h2>
</div>
<div class="expanded">
<h2 class="toggleButton" title="Click to hide Index section">Index ▾</h2>
<!-- Table of contents for API; must be named manual-nav to turn off auto nav. -->
<div id="manual-nav">
<dl>
</dl>
</div><!-- #manual-nav -->
<div id="pkg-examples">
<h4>Examples</h4>
<dl>
<dd><a class="exampleLink" href="#example__diffieHellman">Package (DiffieHellman)</a></dd>
<dd><a class="exampleLink" href="#example__elGamalEncryption">Package (ElGamalEncryption)</a></dd>
</dl>
</div>
<h4>Package files</h4>
<p>
<span style="font-size:90%">
<a href="/src/github.com/dedis/crypto/doc.go">doc.go</a>
</span>
</p>
</div><!-- .expanded -->
</div><!-- #pkg-index -->
<div class="toggle" id="pkg-callgraph" style="display: none">
<div class="collapsed">
<h2 class="toggleButton" title="Click to show Internal Call Graph section">Internal call graph ▹</h2>
</div> <!-- .expanded -->
<div class="expanded">
<h2 class="toggleButton" title="Click to hide Internal Call Graph section">Internal call graph ▾</h2>
<p>
			  In the call graph viewer below, each node
			  is a function belonging to this package
			  and its children are the functions it
			  calls—perhaps dynamically.
			</p>
<p>
			  The root nodes are the entry points of the
			  package: functions that may be called from
			  outside the package.
			  There may be non-exported or anonymous
			  functions among them if they are called
			  dynamically from another package.
			</p>
<p>
			  Click a node to visit that function's source code.
			  From there you can visit its callers by
			  clicking its declaring <code>func</code>
			  token.
			</p>
<p>
			  Functions may be omitted if they were
			  determined to be unreachable in the
			  particular programs or tests that were
			  analyzed.
			</p>
<!-- Zero means show all package entry points. -->
<ul class="treeview" id="callgraph-0" style="margin-left: 0.5in"></ul>
</div>
</div> <!-- #pkg-callgraph -->
<h2 id="pkg-subdirectories">Subdirectories</h2>
<div class="pkg-dir">
<table>
<tr>
<th class="pkg-name">Name</th>
<th class="pkg-synopsis">Synopsis</th>
</tr>
<tr>
<td colspan="2"><a href="..">..</a></td>
</tr>
<tr>
<td class="pkg-name" style="padding-left: 0px;">
<a href="abstract/index.html">abstract</a>
</td>
<td class="pkg-synopsis">
							This package defines abstract interfaces for advanced cryptographic primitives.
						</td>
</tr>
<tr>
<td class="pkg-name" style="padding-left: 0px;">
<a href="anon/index.html">anon</a>
</td>
<td class="pkg-synopsis">
							Package anon implements cryptographic primitives for anonymous communication.
						</td>
</tr>
<tr>
<td class="pkg-name" style="padding-left: 0px;">
<a href="base64/index.html">base64</a>
</td>
<td class="pkg-synopsis">
							Package base64 implements base64 encoding as specified by RFC 4648.
						</td>
</tr>
<tr>
<td class="pkg-name" style="padding-left: 0px;">
<a href="cipher/index.html">cipher</a>
</td>
<td class="pkg-synopsis">
</td>
</tr>
<tr>
<td class="pkg-name" style="padding-left: 20px;">
<a href="cipher/aes/index.html">aes</a>
</td>
<td class="pkg-synopsis">
							Package aes implements the general Cipher interface using AES, SHA2, and HMAC.
						</td>
</tr>
<tr>
<td class="pkg-name" style="padding-left: 20px;">
<a href="cipher/bench/index.html">bench</a>
</td>
<td class="pkg-synopsis">
							This package exists runs comparative benchmarks across several alternative Cipher implementations.
						</td>
</tr>
<tr>
<td class="pkg-name" style="padding-left: 20px;">
<a href="cipher/norx/index.html">norx</a>
</td>
<td class="pkg-synopsis">
							Package NORX implements the experimental NORX cipher.
						</td>
</tr>
<tr>
<td class="pkg-name" style="padding-left: 40px;">
<a href="cipher/norx/check/index.html">check</a>
</td>
<td class="pkg-synopsis">
</td>
</tr>
<tr>
<td class="pkg-name" style="padding-left: 20px;">
<a href="cipher/sha3/index.html">sha3</a>
</td>
<td class="pkg-synopsis">
							Package sha3 implements the SHA-3 fixed-output-length hash functions and the SHAKE variable-output-length hash functions defined by FIPS-202.
						</td>
</tr>
<tr>
<td class="pkg-name" style="padding-left: 0px;">
<a href="clique/index.html">clique</a>
</td>
<td class="pkg-synopsis">
							A clique protocol is an abstraction for a cryptographic protocol in which every participant knows about and interacts directly in lock-step with every other participant in the clique.
						</td>
</tr>
<tr>
<td class="pkg-name" style="padding-left: 0px;">
<a href="config/index.html">config</a>
</td>
<td class="pkg-synopsis">
</td>
</tr>
<tr>
<td class="pkg-name" style="padding-left: 0px;">
<a href="cosi/index.html">cosi</a>
</td>
<td class="pkg-synopsis">
							Package cosi is the Collective Signing implementation according to the paper of Bryan Ford: http://arxiv.org/pdf/1503.08768v1.pdf .
						</td>
</tr>
<tr>
<td class="pkg-name" style="padding-left: 0px;">
<a href="ed25519/index.html">ed25519</a>
</td>
<td class="pkg-synopsis">
							Package ed25519 provides an optimized Go implementation of a Twisted Edwards curve that is isomorphic to Curve25519.
						</td>
</tr>
<tr>
<td class="pkg-name" style="padding-left: 0px;">
<a href="eddsa/index.html">eddsa</a>
</td>
<td class="pkg-synopsis">
</td>
</tr>
<tr>
<td class="pkg-name" style="padding-left: 0px;">
<a href="edwards/index.html">edwards</a>
</td>
<td class="pkg-synopsis">
							This package contains several implementations of Twisted Edwards Curves, from general and unoptimized to highly specialized and optimized.
						</td>
</tr>
<tr>
<td class="pkg-name" style="padding-left: 0px;">
<a href="group/index.html">group</a>
</td>
<td class="pkg-synopsis">
							Package group contains generic facilities for implementing cryptographic groups.
						</td>
</tr>
<tr>
<td class="pkg-name" style="padding-left: 0px;">
<a href="ints/index.html">ints</a>
</td>
<td class="pkg-synopsis">
</td>
</tr>
<tr>
<td class="pkg-name" style="padding-left: 0px;">
<a href="math/index.html">math</a>
</td>
<td class="pkg-synopsis">
							Package dissent/math contains big.Int arithmetic functions that probably belong in Go's math/big package.
						</td>
</tr>
<tr>
<td class="pkg-name" style="padding-left: 0px;">
<a href="nego/index.html">nego</a>
</td>
<td class="pkg-synopsis">
							Package nego implements cryptographic negotiation and secret entrypoint finding.
						</td>
</tr>
<tr>
<td class="pkg-name" style="padding-left: 0px;">
<a href="nist/index.html">nist</a>
</td>
<td class="pkg-synopsis">
							Package nist implements cryptographic groups and ciphersuites based on the NIST standards, using Go's built-in crypto library.
						</td>
</tr>
<tr>
<td class="pkg-name" style="padding-left: 0px;">
<a href="openssl/index.html">openssl</a>
</td>
<td class="pkg-synopsis">
							Package openssl implements a ciphersuite based on OpenSSL's crypto library.
						</td>
</tr>
<tr>
<td class="pkg-name" style="padding-left: 0px;">
<a href="pbc/index.html">pbc</a>
</td>
<td class="pkg-synopsis">
							Package pbc provides a Go wrapper for the Stanford Pairing Based Crypto library.
						</td>
</tr>
<tr>
<td class="pkg-name" style="padding-left: 0px;">
<a href="poly/index.html">poly</a>
</td>
<td class="pkg-synopsis">
							This package implements the Deal cryptographic primitive, which is based * on poly/sharing.go * * Failures are frequent in large-scale systems.
						</td>
</tr>
<tr>
<td class="pkg-name" style="padding-left: 0px;">
<a href="proof/index.html">proof</a>
</td>
<td class="pkg-synopsis">
							Package proof implements generic support for Sigma-protocols and discrete logarithm proofs in the Camenisch/Stadler framework.
						</td>
</tr>
<tr>
<td class="pkg-name" style="padding-left: 0px;">
<a href="random/index.html">random</a>
</td>
<td class="pkg-synopsis">
							Package rand provides facilities for generating random or pseudorandom cryptographic objects.
						</td>
</tr>
<tr>
<td class="pkg-name" style="padding-left: 0px;">
<a href="shuffle/index.html">shuffle</a>
</td>
<td class="pkg-synopsis">
							Package shuffle implements Andrew Neff's verifiable shuffle proof scheme.
						</td>
</tr>
<tr>
<td class="pkg-name" style="padding-left: 0px;">
<a href="sodium/index.html">sodium</a>
</td>
<td class="pkg-synopsis">
							Package sodium contains functionality ported from the Sodium crypto library.
						</td>
</tr>
<tr>
<td class="pkg-name" style="padding-left: 20px;">
<a href="sodium/blake2/index.html">blake2</a>
</td>
<td class="pkg-synopsis">
							This package implements the BLAKE2b cryptographic hash function, described at: https://blake2.net
						</td>
</tr>
<tr>
<td class="pkg-name" style="padding-left: 20px;">
<a href="sodium/ed25519/index.html">ed25519</a>
</td>
<td class="pkg-synopsis">
							Package ed25519 implements Go wrappers for a high-speed implementation of the Ed25519 curve written in C, derived from the implementation in the Sodium crypto library.
						</td>
</tr>
<tr>
<td class="pkg-name" style="padding-left: 0px;">
<a href="subtle/index.html">subtle</a>
</td>
<td class="pkg-synopsis">
</td>
</tr>
<tr>
<td class="pkg-name" style="padding-left: 0px;">
<a href="suites/index.html">suites</a>
</td>
<td class="pkg-synopsis">
							This package contains lists of ciphersuites defined elsewhere in other packages.
						</td>
</tr>
<tr>
<td class="pkg-name" style="padding-left: 0px;">
<a href="test/index.html">test</a>
</td>
<td class="pkg-synopsis">
							Package test contains generic testing and benchmarking infrastructure for cryptographic groups and ciphersuites.
						</td>
</tr>
<tr>
<td class="pkg-name" style="padding-left: 0px;">
<a href="util/index.html">util</a>
</td>
<td class="pkg-synopsis">
</td>
</tr>
</table>
</div>

</div><!-- .container -->
</div><!-- #page -->
<!-- TODO(adonovan): load these from <head> using "defer" attribute? -->
<script src="../../../.goduckstyle/jquery.js" type="text/javascript"></script>
<script src="../../../.goduckstyle/jquery.treeview.js" type="text/javascript"></script>
<script src="../../../.goduckstyle/jquery.treeview.edit.js" type="text/javascript"></script>
<script>var goVersion = "go1.7.1";</script>
<script src="../../../.goduckstyle/godocs.js" type="text/javascript"></script>
</body>
</html>
