<!DOCTYPE html>

<html>
<head>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type">
<meta content="width=device-width, initial-scale=1" name="viewport">
<meta content="#375EAB" name="theme-color">
<title>prifi - The PriFi Project</title>
<link href="../../../../.goduckstyle/style.css" rel="stylesheet" type="text/css">
<link href="../../../../.goduckstyle/jquery.treeview.css" rel="stylesheet">
<script type="text/javascript">window.initFuncs = [];</script>
</link></link></meta></meta></meta></head>
<body>
<div id="lowframe" style="position: fixed; bottom: 0; left: 0; height: 0; width: 100%; border-top: thin solid grey; background-color: white; overflow: auto;">
...
</div><!-- #lowframe -->
<div class="wide" id="topbar"><div class="container">
<div class="top-heading" id="heading-wide">The PriFi Project</div>
<div class="top-heading" id="heading-narrow">The PriFi Project</div>
<a href="#" id="menu-button"><span id="menu-button-arrow">▽</span></a>
<form action="/search" method="GET">
<div id="menu">





</div>
</form>
</div></div>
<div class="wide" id="page">
<div class="container">
<h1>Package prifi</h1>
<div id="nav"></div>
<!--
	Copyright 2009 The Go Authors. All rights reserved.
	Use of this source code is governed by a BSD-style
	license that can be found in the LICENSE file.
-->
<!--
	Note: Static (i.e., not template-generated) href and id
	attributes start with "pkg-" to make it impossible for
	them to conflict with generated attributes (some of which
	correspond to Go identifiers).
-->
<script type="text/javascript">
	document.ANALYSIS_DATA = null;
	document.CALLGRAPH = null;
	</script>
<div id="short-nav">
<dl>
<dd><code>import "github.com/lbarman/prifi_dev/prifi-lib"</code></dd>
</dl>
<dl>
<dd><a class="overviewLink" href="#pkg-overview">Overview</a></dd>
<dd><a class="indexLink" href="#pkg-index">Index</a></dd>
<dd><a href="#pkg-subdirectories">Subdirectories</a></dd>
</dl>
</div>
<!-- The package's Name is printed as title by the top-level template -->
<div class="toggleVisible" id="pkg-overview">
<div class="collapsed">
<h2 class="toggleButton" title="Click to show Overview section">Overview ▹</h2>
</div>
<div class="expanded">
<h2 class="toggleButton" title="Click to hide Overview section">Overview ▾</h2>
<p>
Package prifi contains the implementation of the PriFi protocol.
It is network-agnostic and defines a MessageSender interface to
interact with the network in prifi.go.
</p>
</div>
</div>
<div class="toggleVisible" id="pkg-index">
<div class="collapsed">
<h2 class="toggleButton" title="Click to show Index section">Index ▹</h2>
</div>
<div class="expanded">
<h2 class="toggleButton" title="Click to hide Index section">Index ▾</h2>
<!-- Table of contents for API; must be named manual-nav to turn off auto nav. -->
<div id="manual-nav">
<dl>
<dd><a href="#pkg-constants">Constants</a></dd>
<dd><a href="#MsTimeStamp">func MsTimeStamp() int64</a></dd>
<dd><a href="#ALL_ALL_PARAMETERS">type ALL_ALL_PARAMETERS</a></dd>
<dd><a href="#ALL_ALL_SHUTDOWN">type ALL_ALL_SHUTDOWN</a></dd>
<dd><a href="#BufferedCipher">type BufferedCipher</a></dd>
<dd><a href="#CLI_REL_TELL_PK_AND_EPH_PK">type CLI_REL_TELL_PK_AND_EPH_PK</a></dd>
<dd><a href="#CLI_REL_UPSTREAM_DATA">type CLI_REL_UPSTREAM_DATA</a></dd>
<dd><a href="#ClientState">type ClientState</a></dd>
<dd>    <a href="#NewClientState">func NewClientState(clientId int, nTrustees int, nClients int, payloadLength int, latencyTest bool, useUDP bool, dataOutputEnabled bool) *ClientState</a></dd>
<dd><a href="#DCNetRound">type DCNetRound</a></dd>
<dd><a href="#MessageSender">type MessageSender</a></dd>
<dd><a href="#NeffShuffleResult">type NeffShuffleResult</a></dd>
<dd><a href="#NeffShuffleState">type NeffShuffleState</a></dd>
<dd><a href="#NodeRepresentation">type NodeRepresentation</a></dd>
<dd><a href="#PriFiProtocol">type PriFiProtocol</a></dd>
<dd>    <a href="#NewPriFiClient">func NewPriFiClient(msgSender MessageSender) *PriFiProtocol</a></dd>
<dd>    <a href="#NewPriFiClientWithState">func NewPriFiClientWithState(msgSender MessageSender, state *ClientState) *PriFiProtocol</a></dd>
<dd>    <a href="#NewPriFiRelay">func NewPriFiRelay(msgSender MessageSender) *PriFiProtocol</a></dd>
<dd>    <a href="#NewPriFiRelayWithState">func NewPriFiRelayWithState(msgSender MessageSender, state *RelayState) *PriFiProtocol</a></dd>
<dd>    <a href="#NewPriFiTrustee">func NewPriFiTrustee(msgSender MessageSender) *PriFiProtocol</a></dd>
<dd>    <a href="#NewPriFiTrusteeWithState">func NewPriFiTrusteeWithState(msgSender MessageSender, state *TrusteeState) *PriFiProtocol</a></dd>
<dd>    <a href="#PriFiProtocol.ConnectToTrustees">func (p *PriFiProtocol) ConnectToTrustees() error</a></dd>
<dd>    <a href="#PriFiProtocol.ProcessDownStreamData">func (p *PriFiProtocol) ProcessDownStreamData(msg REL_CLI_DOWNSTREAM_DATA) error</a></dd>
<dd>    <a href="#PriFiProtocol.ReceivedMessage">func (prifi *PriFiProtocol) ReceivedMessage(msg interface{}) error</a></dd>
<dd>    <a href="#PriFiProtocol.Received_ALL_CLI_PARAMETERS">func (p *PriFiProtocol) Received_ALL_CLI_PARAMETERS(msg ALL_ALL_PARAMETERS) error</a></dd>
<dd>    <a href="#PriFiProtocol.Received_ALL_CLI_SHUTDOWN">func (p *PriFiProtocol) Received_ALL_CLI_SHUTDOWN(msg ALL_ALL_SHUTDOWN) error</a></dd>
<dd>    <a href="#PriFiProtocol.Received_ALL_REL_PARAMETERS">func (p *PriFiProtocol) Received_ALL_REL_PARAMETERS(msg ALL_ALL_PARAMETERS) error</a></dd>
<dd>    <a href="#PriFiProtocol.Received_ALL_REL_SHUTDOWN">func (p *PriFiProtocol) Received_ALL_REL_SHUTDOWN(msg ALL_ALL_SHUTDOWN) error</a></dd>
<dd>    <a href="#PriFiProtocol.Received_ALL_TRU_PARAMETERS">func (p *PriFiProtocol) Received_ALL_TRU_PARAMETERS(msg ALL_ALL_PARAMETERS) error</a></dd>
<dd>    <a href="#PriFiProtocol.Received_ALL_TRU_SHUTDOWN">func (p *PriFiProtocol) Received_ALL_TRU_SHUTDOWN(msg ALL_ALL_SHUTDOWN) error</a></dd>
<dd>    <a href="#PriFiProtocol.Received_CLI_REL_TELL_PK_AND_EPH_PK">func (p *PriFiProtocol) Received_CLI_REL_TELL_PK_AND_EPH_PK(msg CLI_REL_TELL_PK_AND_EPH_PK) error</a></dd>
<dd>    <a href="#PriFiProtocol.Received_CLI_REL_UPSTREAM_DATA">func (p *PriFiProtocol) Received_CLI_REL_UPSTREAM_DATA(msg CLI_REL_UPSTREAM_DATA) error</a></dd>
<dd>    <a href="#PriFiProtocol.Received_REL_CLI_DOWNSTREAM_DATA">func (p *PriFiProtocol) Received_REL_CLI_DOWNSTREAM_DATA(msg REL_CLI_DOWNSTREAM_DATA) error</a></dd>
<dd>    <a href="#PriFiProtocol.Received_REL_CLI_TELL_EPH_PKS_AND_TRUSTEES_SIG">func (p *PriFiProtocol) Received_REL_CLI_TELL_EPH_PKS_AND_TRUSTEES_SIG(msg REL_CLI_TELL_EPH_PKS_AND_TRUSTEES_SIG) error</a></dd>
<dd>    <a href="#PriFiProtocol.Received_REL_CLI_TELL_TRUSTEES_PK">func (p *PriFiProtocol) Received_REL_CLI_TELL_TRUSTEES_PK(msg REL_CLI_TELL_TRUSTEES_PK) error</a></dd>
<dd>    <a href="#PriFiProtocol.Received_REL_CLI_UDP_DOWNSTREAM_DATA">func (p *PriFiProtocol) Received_REL_CLI_UDP_DOWNSTREAM_DATA(msg REL_CLI_DOWNSTREAM_DATA) error</a></dd>
<dd>    <a href="#PriFiProtocol.Received_REL_TRU_TELL_CLIENTS_PKS_AND_EPH_PKS_AND_BASE">func (p *PriFiProtocol) Received_REL_TRU_TELL_CLIENTS_PKS_AND_EPH_PKS_AND_BASE(msg REL_TRU_TELL_CLIENTS_PKS_AND_EPH_PKS_AND_BASE) error</a></dd>
<dd>    <a href="#PriFiProtocol.Received_REL_TRU_TELL_RATE_CHANGE">func (p *PriFiProtocol) Received_REL_TRU_TELL_RATE_CHANGE(msg REL_TRU_TELL_RATE_CHANGE) error</a></dd>
<dd>    <a href="#PriFiProtocol.Received_REL_TRU_TELL_TRANSCRIPT">func (p *PriFiProtocol) Received_REL_TRU_TELL_TRANSCRIPT(msg REL_TRU_TELL_TRANSCRIPT) error</a></dd>
<dd>    <a href="#PriFiProtocol.Received_TRU_REL_DC_CIPHER">func (p *PriFiProtocol) Received_TRU_REL_DC_CIPHER(msg TRU_REL_DC_CIPHER) error</a></dd>
<dd>    <a href="#PriFiProtocol.Received_TRU_REL_SHUFFLE_SIG">func (p *PriFiProtocol) Received_TRU_REL_SHUFFLE_SIG(msg TRU_REL_SHUFFLE_SIG) error</a></dd>
<dd>    <a href="#PriFiProtocol.Received_TRU_REL_TELL_NEW_BASE_AND_EPH_PKS">func (p *PriFiProtocol) Received_TRU_REL_TELL_NEW_BASE_AND_EPH_PKS(msg TRU_REL_TELL_NEW_BASE_AND_EPH_PKS) error</a></dd>
<dd>    <a href="#PriFiProtocol.Received_TRU_REL_TELL_PK">func (p *PriFiProtocol) Received_TRU_REL_TELL_PK(msg TRU_REL_TELL_PK) error</a></dd>
<dd>    <a href="#PriFiProtocol.SendUpstreamData">func (p *PriFiProtocol) SendUpstreamData() error</a></dd>
<dd>    <a href="#PriFiProtocol.Send_TRU_REL_DC_CIPHER">func (p *PriFiProtocol) Send_TRU_REL_DC_CIPHER(rateChan chan int16)</a></dd>
<dd>    <a href="#PriFiProtocol.Send_TRU_REL_PK">func (p *PriFiProtocol) Send_TRU_REL_PK() error</a></dd>
<dd>    <a href="#PriFiProtocol.WhoAmI">func (prifi *PriFiProtocol) WhoAmI()</a></dd>
<dd><a href="#REL_CLI_DOWNSTREAM_DATA">type REL_CLI_DOWNSTREAM_DATA</a></dd>
<dd><a href="#REL_CLI_DOWNSTREAM_DATA_UDP">type REL_CLI_DOWNSTREAM_DATA_UDP</a></dd>
<dd>    <a href="#REL_CLI_DOWNSTREAM_DATA_UDP.FromBytes">func (m *REL_CLI_DOWNSTREAM_DATA_UDP) FromBytes() (interface{}, error)</a></dd>
<dd>    <a href="#REL_CLI_DOWNSTREAM_DATA_UDP.Print">func (m REL_CLI_DOWNSTREAM_DATA_UDP) Print()</a></dd>
<dd>    <a href="#REL_CLI_DOWNSTREAM_DATA_UDP.SetBytes">func (m *REL_CLI_DOWNSTREAM_DATA_UDP) SetBytes(data []byte)</a></dd>
<dd>    <a href="#REL_CLI_DOWNSTREAM_DATA_UDP.ToBytes">func (m *REL_CLI_DOWNSTREAM_DATA_UDP) ToBytes() ([]byte, error)</a></dd>
<dd><a href="#REL_CLI_TELL_EPH_PKS_AND_TRUSTEES_SIG">type REL_CLI_TELL_EPH_PKS_AND_TRUSTEES_SIG</a></dd>
<dd><a href="#REL_CLI_TELL_TRUSTEES_PK">type REL_CLI_TELL_TRUSTEES_PK</a></dd>
<dd><a href="#REL_TRU_TELL_CLIENTS_PKS_AND_EPH_PKS_AND_BASE">type REL_TRU_TELL_CLIENTS_PKS_AND_EPH_PKS_AND_BASE</a></dd>
<dd><a href="#REL_TRU_TELL_RATE_CHANGE">type REL_TRU_TELL_RATE_CHANGE</a></dd>
<dd><a href="#REL_TRU_TELL_TRANSCRIPT">type REL_TRU_TELL_TRANSCRIPT</a></dd>
<dd><a href="#RelayState">type RelayState</a></dd>
<dd>    <a href="#NewRelayState">func NewRelayState(nTrustees int, nClients int, upstreamCellSize int, downstreamCellSize int, windowSize int, useDummyDataDown bool, experimentRoundLimit int, experimentResultChan chan interface{}, useUDP bool, dataOutputEnabled bool) *RelayState</a></dd>
<dd><a href="#TRU_REL_DC_CIPHER">type TRU_REL_DC_CIPHER</a></dd>
<dd><a href="#TRU_REL_SHUFFLE_SIG">type TRU_REL_SHUFFLE_SIG</a></dd>
<dd><a href="#TRU_REL_TELL_NEW_BASE_AND_EPH_PKS">type TRU_REL_TELL_NEW_BASE_AND_EPH_PKS</a></dd>
<dd><a href="#TRU_REL_TELL_PK">type TRU_REL_TELL_PK</a></dd>
<dd><a href="#TrusteeState">type TrusteeState</a></dd>
<dd>    <a href="#NewTrusteeState">func NewTrusteeState(trusteeId int, nClients int, nTrustees int, payloadLength int) *TrusteeState</a></dd>
</dl>
</div><!-- #manual-nav -->
<h4>Package files</h4>
<p>
<span style="font-size:90%">
<a href="/src/github.com/lbarman/prifi_dev/prifi-lib/client.go">client.go</a>
<a href="/src/github.com/lbarman/prifi_dev/prifi-lib/doc.go">doc.go</a>
<a href="/src/github.com/lbarman/prifi_dev/prifi-lib/messages.go">messages.go</a>
<a href="/src/github.com/lbarman/prifi_dev/prifi-lib/prifi.go">prifi.go</a>
<a href="/src/github.com/lbarman/prifi_dev/prifi-lib/relay.go">relay.go</a>
<a href="/src/github.com/lbarman/prifi_dev/prifi-lib/trustee.go">trustee.go</a>
</span>
</p>
</div><!-- .expanded -->
</div><!-- #pkg-index -->
<div class="toggle" id="pkg-callgraph" style="display: none">
<div class="collapsed">
<h2 class="toggleButton" title="Click to show Internal Call Graph section">Internal call graph ▹</h2>
</div> <!-- .expanded -->
<div class="expanded">
<h2 class="toggleButton" title="Click to hide Internal Call Graph section">Internal call graph ▾</h2>
<p>
			  In the call graph viewer below, each node
			  is a function belonging to this package
			  and its children are the functions it
			  calls—perhaps dynamically.
			</p>
<p>
			  The root nodes are the entry points of the
			  package: functions that may be called from
			  outside the package.
			  There may be non-exported or anonymous
			  functions among them if they are called
			  dynamically from another package.
			</p>
<p>
			  Click a node to visit that function's source code.
			  From there you can visit its callers by
			  clicking its declaring <code>func</code>
			  token.
			</p>
<p>
			  Functions may be omitted if they were
			  determined to be unreachable in the
			  particular programs or tests that were
			  analyzed.
			</p>
<!-- Zero means show all package entry points. -->
<ul class="treeview" id="callgraph-0" style="margin-left: 0.5in"></ul>
</div>
</div> <!-- #pkg-callgraph -->
<h2 id="pkg-constants">Constants</h2>
<pre>const (
    <span id="CLIENT_STATE_BEFORE_INIT">CLIENT_STATE_BEFORE_INIT</span> <a href="https://golang.org/pkg/builtin/#int16">int16</a> = <a href="https://golang.org/pkg/builtin/#iota">iota</a>
    <span id="CLIENT_STATE_INITIALIZING">CLIENT_STATE_INITIALIZING</span>
    <span id="CLIENT_STATE_EPH_KEYS_SENT">CLIENT_STATE_EPH_KEYS_SENT</span>
    <span id="CLIENT_STATE_READY">CLIENT_STATE_READY</span>
    <span id="CLIENT_STATE_SHUTDOWN">CLIENT_STATE_SHUTDOWN</span>
)</pre>
<p>
Possible states of the clients. This restrict the kind of messages they can receive at a given point in time.
</p>
<pre>const (
    <span id="PRIFI_ROLE_UNDEFINED">PRIFI_ROLE_UNDEFINED</span> <a href="https://golang.org/pkg/builtin/#int16">int16</a> = <a href="https://golang.org/pkg/builtin/#iota">iota</a>
    <span id="PRIFI_ROLE_RELAY">PRIFI_ROLE_RELAY</span>
    <span id="PRIFI_ROLE_CLIENT">PRIFI_ROLE_CLIENT</span>
    <span id="PRIFI_ROLE_TRUSTEE">PRIFI_ROLE_TRUSTEE</span>
)</pre>
<p>
Possible role of PriFi entities.
The role restricts the kind of messages an entity can receive at
a given point in time. The roles are mutually exclusive.
</p>
<pre>const (
    <span id="RELAY_STATE_BEFORE_INIT">RELAY_STATE_BEFORE_INIT</span> <a href="https://golang.org/pkg/builtin/#int16">int16</a> = <a href="https://golang.org/pkg/builtin/#iota">iota</a>
    <span id="RELAY_STATE_COLLECTING_TRUSTEES_PKS">RELAY_STATE_COLLECTING_TRUSTEES_PKS</span>
    <span id="RELAY_STATE_COLLECTING_CLIENT_PKS">RELAY_STATE_COLLECTING_CLIENT_PKS</span>
    <span id="RELAY_STATE_COLLECTING_SHUFFLES">RELAY_STATE_COLLECTING_SHUFFLES</span>
    <span id="RELAY_STATE_COLLECTING_SHUFFLE_SIGNATURES">RELAY_STATE_COLLECTING_SHUFFLE_SIGNATURES</span>
    <span id="RELAY_STATE_COMMUNICATING">RELAY_STATE_COMMUNICATING</span>
    <span id="RELAY_STATE_SHUTDOWN">RELAY_STATE_SHUTDOWN</span>
)</pre>
<p>
Possible states the trustees are in. This restrict the kind of messages they can receive at a given point in time.
</p>
<pre>const (
    <span id="TRUSTEE_STATE_BEFORE_INIT">TRUSTEE_STATE_BEFORE_INIT</span> <a href="https://golang.org/pkg/builtin/#int16">int16</a> = <a href="https://golang.org/pkg/builtin/#iota">iota</a>
    <span id="TRUSTEE_STATE_INITIALIZING">TRUSTEE_STATE_INITIALIZING</span>
    <span id="TRUSTEE_STATE_SHUFFLE_DONE">TRUSTEE_STATE_SHUFFLE_DONE</span>
    <span id="TRUSTEE_STATE_READY">TRUSTEE_STATE_READY</span>
    <span id="TRUSTEE_STATE_SHUTDOWN">TRUSTEE_STATE_SHUTDOWN</span>
)</pre>
<p>
Possible states the trustees are in. This restrict the kind of messages they can receive at a given point in time.
</p>
<pre>const (
    <span id="TRUSTEE_KILL_SEND_PROCESS">TRUSTEE_KILL_SEND_PROCESS</span> <a href="https://golang.org/pkg/builtin/#int16">int16</a> = <a href="https://golang.org/pkg/builtin/#iota">iota</a> <span class="comment">// kills the goroutine responsible for sending messages</span>
    <span id="TRUSTEE_RATE_ACTIVE">TRUSTEE_RATE_ACTIVE</span>
    <span id="TRUSTEE_RATE_STOPPED">TRUSTEE_RATE_STOPPED</span>
)</pre>
<p>
Possible sending rates for the trustees.
</p>
<pre>const <span id="CLIENT_FAILED_CONNECTION_WAIT_BEFORE_RETRY">CLIENT_FAILED_CONNECTION_WAIT_BEFORE_RETRY</span> = 1000 * <a href="../../../../time/index.html">time</a>.<a href="../../../../time/index.html#Millisecond">Millisecond</a></pre>
<pre>const <span id="CLIENT_READ_TIMEOUT">CLIENT_READ_TIMEOUT</span> = 5 * <a href="../../../../time/index.html">time</a>.<a href="../../../../time/index.html#Second">Second</a></pre>
<pre>const <span id="CONTROL_LOOP_SLEEP_TIME">CONTROL_LOOP_SLEEP_TIME</span> = 1 * <a href="../../../../time/index.html">time</a>.<a href="../../../../time/index.html#Second">Second</a></pre>
<p>
Constants
</p>
<pre>const <span id="INBETWEEN_CONFIG_SLEEP_TIME">INBETWEEN_CONFIG_SLEEP_TIME</span> = 0 * <a href="../../../../time/index.html">time</a>.<a href="../../../../time/index.html#Second">Second</a></pre>
<pre>const <span id="MAX_ALLOWED_TRUSTEE_CIPHERS_BUFFERED">MAX_ALLOWED_TRUSTEE_CIPHERS_BUFFERED</span> = 10</pre>
<pre>const <span id="MaxUint">MaxUint</span> <a href="https://golang.org/pkg/builtin/#uint32">uint32</a> = <a href="https://golang.org/pkg/builtin/#uint32">uint32</a>(4294967295)</pre>
<pre>const <span id="NEWCLIENT_CHECK_SLEEP_TIME">NEWCLIENT_CHECK_SLEEP_TIME</span> = 10 * <a href="../../../../time/index.html">time</a>.<a href="../../../../time/index.html#Millisecond">Millisecond</a></pre>
<pre>const <span id="PROCESSING_LOOP_SLEEP_TIME">PROCESSING_LOOP_SLEEP_TIME</span> = 0 * <a href="../../../../time/index.html">time</a>.<a href="../../../../time/index.html#Second">Second</a></pre>
<pre>const <span id="RELAY_FAILED_CONNECTION_WAIT_BEFORE_RETRY">RELAY_FAILED_CONNECTION_WAIT_BEFORE_RETRY</span> = 10 * <a href="../../../../time/index.html">time</a>.<a href="../../../../time/index.html#Second">Second</a></pre>
<pre>const <span id="RESUME_SENDING_CAPACITY_RATIO">RESUME_SENDING_CAPACITY_RATIO</span> = 0.9</pre>
<p>
Trustees resume sending when capacity = lower limit + ratio*(max - lower limit)
</p>
<pre>const <span id="TRUSTEE_BASE_SLEEP_TIME">TRUSTEE_BASE_SLEEP_TIME</span> = 10 * <a href="../../../../time/index.html">time</a>.<a href="../../../../time/index.html#Millisecond">Millisecond</a></pre>
<p>
TRUSTEE_BASE_SLEEP_TIME is the base unit for how much time the trustee sleeps between sending ciphers to the relay.
</p>
<pre>const <span id="TRUSTEE_WINDOW_LOWER_LIMIT">TRUSTEE_WINDOW_LOWER_LIMIT</span> = 1</pre>
<p>
Trustees stop sending when capacity &lt;= lower limit
</p>
<pre>const <span id="UDP_DATAGRAM_WAIT_TIMEOUT">UDP_DATAGRAM_WAIT_TIMEOUT</span> = 5 * <a href="../../../../time/index.html">time</a>.<a href="../../../../time/index.html#Second">Second</a></pre>
<pre>const <span id="WAIT_FOR_PUBLICKEY_SLEEP_TIME">WAIT_FOR_PUBLICKEY_SLEEP_TIME</span> = 100 * <a href="../../../../time/index.html">time</a>.<a href="../../../../time/index.html#Millisecond">Millisecond</a></pre>
<h2 id="MsTimeStamp">func <a href="/src/github.com/lbarman/prifi_dev/prifi-lib/client.go?s=24728:24752#L587">MsTimeStamp</a>
<a class="permalink" href="#MsTimeStamp">¶</a>
</h2>
<pre>func MsTimeStamp() <a href="https://golang.org/pkg/builtin/#int64">int64</a></pre>
<p>
MsTimeStamp returns the current timestamp, in milliseconds.
</p>
<h2 id="ALL_ALL_PARAMETERS">type <a href="/src/github.com/lbarman/prifi_dev/prifi-lib/messages.go?s=993:1469#L34">ALL_ALL_PARAMETERS</a>
<a class="permalink" href="#ALL_ALL_PARAMETERS">¶</a>
</h2>
<pre>type ALL_ALL_PARAMETERS struct {
    ClientDataOutputEnabled <a href="https://golang.org/pkg/builtin/#bool">bool</a>
    DoLatencyTests          <a href="https://golang.org/pkg/builtin/#bool">bool</a>
    DownCellSize            <a href="https://golang.org/pkg/builtin/#int">int</a>
    ForceParams             <a href="https://golang.org/pkg/builtin/#bool">bool</a>
    NClients                <a href="https://golang.org/pkg/builtin/#int">int</a>
    NextFreeClientId        <a href="https://golang.org/pkg/builtin/#int">int</a>
    NextFreeTrusteeId       <a href="https://golang.org/pkg/builtin/#int">int</a>
    NTrustees               <a href="https://golang.org/pkg/builtin/#int">int</a>
    RelayDataOutputEnabled  <a href="https://golang.org/pkg/builtin/#bool">bool</a>
    RelayReportingLimit     <a href="https://golang.org/pkg/builtin/#int">int</a>
    RelayUseDummyDataDown   <a href="https://golang.org/pkg/builtin/#bool">bool</a>
    RelayWindowSize         <a href="https://golang.org/pkg/builtin/#int">int</a>
    StartNow                <a href="https://golang.org/pkg/builtin/#bool">bool</a>
    UpCellSize              <a href="https://golang.org/pkg/builtin/#int">int</a>
    UseUDP                  <a href="https://golang.org/pkg/builtin/#bool">bool</a>
}</pre>
<p>
ALL_ALL_PARAMETERS message contains all the parameters used by the protocol.
</p>
<h2 id="ALL_ALL_SHUTDOWN">type <a href="/src/github.com/lbarman/prifi_dev/prifi-lib/messages.go?s=879:911#L30">ALL_ALL_SHUTDOWN</a>
<a class="permalink" href="#ALL_ALL_SHUTDOWN">¶</a>
</h2>
<pre>type ALL_ALL_SHUTDOWN struct {
}</pre>
<p>
ALL_ALL_SHUTDOWN message tells the participants to stop the protocol.
</p>
<h2 id="BufferedCipher">type <a href="/src/github.com/lbarman/prifi_dev/prifi-lib/relay.go?s=5129:5198#L110">BufferedCipher</a>
<a class="permalink" href="#BufferedCipher">¶</a>
</h2>
<pre>type BufferedCipher struct {
    RoundId <a href="https://golang.org/pkg/builtin/#int32">int32</a>
    Data    map[<a href="https://golang.org/pkg/builtin/#int">int</a>][]<a href="https://golang.org/pkg/builtin/#byte">byte</a>
}</pre>
<p>
BufferedCipher holds the ciphertexts received in advance from the trustees.
</p>
<h2 id="CLI_REL_TELL_PK_AND_EPH_PK">type <a href="/src/github.com/lbarman/prifi_dev/prifi-lib/messages.go?s=1592:1678#L54">CLI_REL_TELL_PK_AND_EPH_PK</a>
<a class="permalink" href="#CLI_REL_TELL_PK_AND_EPH_PK">¶</a>
</h2>
<pre>type CLI_REL_TELL_PK_AND_EPH_PK struct {
    Pk    <a href="../../../../github.com/dedis/crypto/abstract/index.html">abstract</a>.<a href="../../../../github.com/dedis/crypto/abstract/index.html#Point">Point</a>
    EphPk <a href="../../../../github.com/dedis/crypto/abstract/index.html">abstract</a>.<a href="../../../../github.com/dedis/crypto/abstract/index.html#Point">Point</a>
}</pre>
<p>
CLI_REL_TELL_PK_AND_EPH_PK message contains the public key and ephemeral key of a client
and is sent to the relay.
</p>
<h2 id="CLI_REL_UPSTREAM_DATA">type <a href="/src/github.com/lbarman/prifi_dev/prifi-lib/messages.go?s=1799:1883#L61">CLI_REL_UPSTREAM_DATA</a>
<a class="permalink" href="#CLI_REL_UPSTREAM_DATA">¶</a>
</h2>
<pre>type CLI_REL_UPSTREAM_DATA struct {
    ClientId <a href="https://golang.org/pkg/builtin/#int">int</a>
    RoundId  <a href="https://golang.org/pkg/builtin/#int32">int32</a>
    Data     []<a href="https://golang.org/pkg/builtin/#byte">byte</a>
}</pre>
<p>
CLI_REL_UPSTREAM_DATA message contains the upstream data of a client for a given round
and is sent to the relay.
</p>
<h2 id="ClientState">type <a href="/src/github.com/lbarman/prifi_dev/prifi-lib/client.go?s=2278:3442#L48">ClientState</a>
<a class="permalink" href="#ClientState">¶</a>
</h2>
<pre>type ClientState struct {
    <a href="../../../../sync/index.html">sync</a>.<a href="../../../../sync/index.html#RWMutex">RWMutex</a>
    CellCoder <a href="../../../../github.com/lbarman/prifi_dev/prifi-lib/dcnet/index.html">dcnet</a>.<a href="../../../../github.com/lbarman/prifi_dev/prifi-lib/dcnet/index.html#CellCoder">CellCoder</a>

    DataForDCNet      chan []<a href="https://golang.org/pkg/builtin/#byte">byte</a> <span class="comment">//Data to the relay : VPN / SOCKS should put data there !</span>
    DataFromDCNet     chan []<a href="https://golang.org/pkg/builtin/#byte">byte</a> <span class="comment">//Data from the relay : VPN / SOCKS should read data from there !</span>
    DataOutputEnabled <a href="https://golang.org/pkg/builtin/#bool">bool</a>        <span class="comment">//if FALSE, nothing will be written to DataFromDCNet</span>

    EphemeralPublicKey <a href="../../../../github.com/dedis/crypto/abstract/index.html">abstract</a>.<a href="../../../../github.com/dedis/crypto/abstract/index.html#Point">Point</a>
    Id                 <a href="https://golang.org/pkg/builtin/#int">int</a>
    LatencyTest        <a href="https://golang.org/pkg/builtin/#bool">bool</a>
    MySlot             <a href="https://golang.org/pkg/builtin/#int">int</a>
    Name               <a href="https://golang.org/pkg/builtin/#string">string</a>

    PayloadLength <a href="https://golang.org/pkg/builtin/#int">int</a>

    PublicKey <a href="../../../../github.com/dedis/crypto/abstract/index.html">abstract</a>.<a href="../../../../github.com/dedis/crypto/abstract/index.html#Point">Point</a>

    TrusteePublicKey          []<a href="../../../../github.com/dedis/crypto/abstract/index.html">abstract</a>.<a href="../../../../github.com/dedis/crypto/abstract/index.html#Point">Point</a>
    UsablePayloadLength       <a href="https://golang.org/pkg/builtin/#int">int</a>
    UseSocksProxy             <a href="https://golang.org/pkg/builtin/#bool">bool</a>
    UseUDP                    <a href="https://golang.org/pkg/builtin/#bool">bool</a>
    MessageHistory            <a href="../../../../github.com/dedis/crypto/abstract/index.html">abstract</a>.<a href="../../../../github.com/dedis/crypto/abstract/index.html#Cipher">Cipher</a>
    StartStopReceiveBroadcast chan <a href="https://golang.org/pkg/builtin/#bool">bool</a>

    <span class="comment">//concurrent stuff</span>
    RoundNo           <a href="https://golang.org/pkg/builtin/#int32">int32</a>
    BufferedRoundData map[<a href="https://golang.org/pkg/builtin/#int32">int32</a>]<a href="#REL_CLI_DOWNSTREAM_DATA">REL_CLI_DOWNSTREAM_DATA</a>
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
<p>
ClientState contains the mutable state of the client.
</p>
<h3 id="NewClientState">func <a href="/src/github.com/lbarman/prifi_dev/prifi-lib/client.go?s=3529:3678#L81">NewClientState</a>
<a class="permalink" href="#NewClientState">¶</a>
</h3>
<pre>func NewClientState(clientId <a href="https://golang.org/pkg/builtin/#int">int</a>, nTrustees <a href="https://golang.org/pkg/builtin/#int">int</a>, nClients <a href="https://golang.org/pkg/builtin/#int">int</a>, payloadLength <a href="https://golang.org/pkg/builtin/#int">int</a>, latencyTest <a href="https://golang.org/pkg/builtin/#bool">bool</a>, useUDP <a href="https://golang.org/pkg/builtin/#bool">bool</a>, dataOutputEnabled <a href="https://golang.org/pkg/builtin/#bool">bool</a>) *<a href="#ClientState">ClientState</a></pre>
<p>
Used to initialize the state of the client. Must be called before anything else.
</p>
<h2 id="DCNetRound">type <a href="/src/github.com/lbarman/prifi_dev/prifi-lib/relay.go?s=4514:4754#L91">DCNetRound</a>
<a class="permalink" href="#DCNetRound">¶</a>
</h2>
<pre>type DCNetRound struct {
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
<p>
DCNetRound counts how many (upstream) messages we received for a given DC-net round.
</p>
<h2 id="MessageSender">type <a href="/src/github.com/lbarman/prifi_dev/prifi-lib/prifi.go?s=1099:2068#L29">MessageSender</a>
<a class="permalink" href="#MessageSender">¶</a>
</h2>
<pre>type MessageSender interface {
    <span class="comment">// SendToClient tries to deliver the message "msg" to the client i.</span>
    SendToClient(i <a href="https://golang.org/pkg/builtin/#int">int</a>, msg interface{}) <a href="https://golang.org/pkg/builtin/#error">error</a>

    <span class="comment">// SendToTrustee tries to deliver the message "msg" to the trustee i.</span>
    SendToTrustee(i <a href="https://golang.org/pkg/builtin/#int">int</a>, msg interface{}) <a href="https://golang.org/pkg/builtin/#error">error</a>

    <span class="comment">// SendToRelay tries to deliver the message "msg" to the relay.</span>
    SendToRelay(msg interface{}) <a href="https://golang.org/pkg/builtin/#error">error</a>

    <span class="comment">/*
        BroadcastToAllClients tries to deliver the message "msg"
        to every client, possibly using broadcast.
    */</span>
    BroadcastToAllClients(msg interface{}) <a href="https://golang.org/pkg/builtin/#error">error</a>

    <span class="comment">/*
        ClientSubscribeToBroadcast should be called by the Clients
        in order to receive the Broadcast messages.
        Calling the function starts the handler but does not actually
        listen for broadcast messages.
        Sending true to startStopChan starts receiving the broadcasts.
        Sending false to startStopChan stops receiving the broadcasts.
    */</span>
    ClientSubscribeToBroadcast(clientName <a href="https://golang.org/pkg/builtin/#string">string</a>, protocolInstance *<a href="#PriFiProtocol">PriFiProtocol</a>, startStopChan chan <a href="https://golang.org/pkg/builtin/#bool">bool</a>) <a href="https://golang.org/pkg/builtin/#error">error</a>
}</pre>
<p>
MessageSender is the interface that abstracts the network
interactions.
</p>
<h2 id="NeffShuffleResult">type <a href="/src/github.com/lbarman/prifi_dev/prifi-lib/trustee.go?s=2652:2745#L64">NeffShuffleResult</a>
<a class="permalink" href="#NeffShuffleResult">¶</a>
</h2>
<pre>type NeffShuffleResult struct {
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
<p>
NeffShuffleResult holds the result of the NeffShuffle,
since it needs to be verified when we receive REL_TRU_TELL_TRANSCRIPT.
</p>
<h2 id="NeffShuffleState">type <a href="/src/github.com/lbarman/prifi_dev/prifi-lib/relay.go?s=4180:4424#L80">NeffShuffleState</a>
<a class="permalink" href="#NeffShuffleState">¶</a>
</h2>
<pre>type NeffShuffleState struct {
    ClientPublicKeys []<a href="../../../../github.com/dedis/crypto/abstract/index.html">abstract</a>.<a href="../../../../github.com/dedis/crypto/abstract/index.html#Point">Point</a>
    G_s              []<a href="../../../../github.com/dedis/crypto/abstract/index.html">abstract</a>.<a href="../../../../github.com/dedis/crypto/abstract/index.html#Point">Point</a>
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
<p>
NeffShuffleState is where the Neff Shuffles are accumulated during the Schedule protocol.
</p>
<h2 id="NodeRepresentation">type <a href="/src/github.com/lbarman/prifi_dev/prifi-lib/relay.go?s=3932:4085#L72">NodeRepresentation</a>
<a class="permalink" href="#NodeRepresentation">¶</a>
</h2>
<pre>type NodeRepresentation struct {
    Id                 <a href="https://golang.org/pkg/builtin/#int">int</a>
    Connected          <a href="https://golang.org/pkg/builtin/#bool">bool</a>
    PublicKey          <a href="../../../../github.com/dedis/crypto/abstract/index.html">abstract</a>.<a href="../../../../github.com/dedis/crypto/abstract/index.html#Point">Point</a>
    EphemeralPublicKey <a href="../../../../github.com/dedis/crypto/abstract/index.html">abstract</a>.<a href="../../../../github.com/dedis/crypto/abstract/index.html#Point">Point</a>
}</pre>
<p>
NodeRepresentation regroups the information about one client or trustee.
</p>
<h2 id="PriFiProtocol">type <a href="/src/github.com/lbarman/prifi_dev/prifi-lib/prifi.go?s=444:752#L8">PriFiProtocol</a>
<a class="permalink" href="#PriFiProtocol">¶</a>
</h2>
<pre>type PriFiProtocol struct {
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
<p>
PriFiProtocol contains the mutable state of a PriFi entity.
</p>
<h3 id="NewPriFiClient">func <a href="/src/github.com/lbarman/prifi_dev/prifi-lib/prifi.go?s=3130:3189#L80">NewPriFiClient</a>
<a class="permalink" href="#NewPriFiClient">¶</a>
</h3>
<pre>func NewPriFiClient(msgSender <a href="#MessageSender">MessageSender</a>) *<a href="#PriFiProtocol">PriFiProtocol</a></pre>
<p>
NewPriFiClient creates a new PriFi client entity state.
Note: the returned state is not sufficient for the PrFi protocol
to start; this entity will expect a ALL_ALL_PARAMETERS message as
first received message to complete it's state.
</p>
<h3 id="NewPriFiClientWithState">func <a href="/src/github.com/lbarman/prifi_dev/prifi-lib/prifi.go?s=4141:4229#L113">NewPriFiClientWithState</a>
<a class="permalink" href="#NewPriFiClientWithState">¶</a>
</h3>
<pre>func NewPriFiClientWithState(msgSender <a href="#MessageSender">MessageSender</a>, state *<a href="#ClientState">ClientState</a>) *<a href="#PriFiProtocol">PriFiProtocol</a></pre>
<p>
NewPriFiClientWithState creates a new PriFi client entity state.
</p>
<h3 id="NewPriFiRelay">func <a href="/src/github.com/lbarman/prifi_dev/prifi-lib/prifi.go?s=2713:2771#L67">NewPriFiRelay</a>
<a class="permalink" href="#NewPriFiRelay">¶</a>
</h3>
<pre>func NewPriFiRelay(msgSender <a href="#MessageSender">MessageSender</a>) *<a href="#PriFiProtocol">PriFiProtocol</a></pre>
<p>
NewPriFiRelay creates a new PriFi relay entity state.
Note: the returned state is not sufficient for the PrFi protocol
to start; this entity will expect a ALL_ALL_PARAMETERS message as
first received message to complete it's state.
</p>
<h3 id="NewPriFiRelayWithState">func <a href="/src/github.com/lbarman/prifi_dev/prifi-lib/prifi.go?s=3790:3876#L101">NewPriFiRelayWithState</a>
<a class="permalink" href="#NewPriFiRelayWithState">¶</a>
</h3>
<pre>func NewPriFiRelayWithState(msgSender <a href="#MessageSender">MessageSender</a>, state *<a href="#RelayState">RelayState</a>) *<a href="#PriFiProtocol">PriFiProtocol</a></pre>
<p>
NewPriFiRelayWithState creates a new PriFi relay entity state.
</p>
<h3 id="NewPriFiTrustee">func <a href="/src/github.com/lbarman/prifi_dev/prifi-lib/prifi.go?s=3550:3610#L92">NewPriFiTrustee</a>
<a class="permalink" href="#NewPriFiTrustee">¶</a>
</h3>
<pre>func NewPriFiTrustee(msgSender <a href="#MessageSender">MessageSender</a>) *<a href="#PriFiProtocol">PriFiProtocol</a></pre>
<p>
NewPriFiTrustee creates a new PriFi trustee entity state.
Note: the returned state is not sufficient for the PrFi protocol
to start; this entity will expect a ALL_ALL_PARAMETERS message as
first received message to complete it's state.
</p>
<h3 id="NewPriFiTrusteeWithState">func <a href="/src/github.com/lbarman/prifi_dev/prifi-lib/prifi.go?s=4733:4823#L127">NewPriFiTrusteeWithState</a>
<a class="permalink" href="#NewPriFiTrusteeWithState">¶</a>
</h3>
<pre>func NewPriFiTrusteeWithState(msgSender <a href="#MessageSender">MessageSender</a>, state *<a href="#TrusteeState">TrusteeState</a>) *<a href="#PriFiProtocol">PriFiProtocol</a></pre>
<p>
NewPriFiTrusteeWithState creates a new PriFi trustee entity state.
</p>
<h3 id="PriFiProtocol.ConnectToTrustees">func (*PriFiProtocol) <a href="/src/github.com/lbarman/prifi_dev/prifi-lib/relay.go?s=12191:12240#L297">ConnectToTrustees</a>
<a class="permalink" href="#PriFiProtocol.ConnectToTrustees">¶</a>
</h3>
<pre>func (p *<a href="#PriFiProtocol">PriFiProtocol</a>) ConnectToTrustees() <a href="https://golang.org/pkg/builtin/#error">error</a></pre>
<p>
ConnectToTrustees connects to the trustees and initializes them with default parameters.
</p>
<h3 id="PriFiProtocol.ProcessDownStreamData">func (*PriFiProtocol) <a href="/src/github.com/lbarman/prifi_dev/prifi-lib/client.go?s=13073:13153#L287">ProcessDownStreamData</a>
<a class="permalink" href="#PriFiProtocol.ProcessDownStreamData">¶</a>
</h3>
<pre>func (p *<a href="#PriFiProtocol">PriFiProtocol</a>) ProcessDownStreamData(msg <a href="#REL_CLI_DOWNSTREAM_DATA">REL_CLI_DOWNSTREAM_DATA</a>) <a href="https://golang.org/pkg/builtin/#error">error</a></pre>
<p>
ProcessDownStreamData handles the downstream data. After determining if the data is for us (this is not done yet), we test if it's a
latency-test message, test if the resync flag is on (which triggers a re-setup).
When this function ends, it calls SendUpstreamData() which continues the communication loop.
</p>
<h3 id="PriFiProtocol.ReceivedMessage">func (*PriFiProtocol) <a href="/src/github.com/lbarman/prifi_dev/prifi-lib/messages.go?s=7140:7206#L218">ReceivedMessage</a>
<a class="permalink" href="#PriFiProtocol.ReceivedMessage">¶</a>
</h3>
<pre>func (prifi *<a href="#PriFiProtocol">PriFiProtocol</a>) ReceivedMessage(msg interface{}) <a href="https://golang.org/pkg/builtin/#error">error</a></pre>
<p>
ReceivedMessage must be called when a PriFi host receives a message.
It takes care to call the correct message handler function.
</p>
<h3 id="PriFiProtocol.Received_ALL_CLI_PARAMETERS">func (*PriFiProtocol) <a href="/src/github.com/lbarman/prifi_dev/prifi-lib/client.go?s=6189:6270#L154">Received_ALL_CLI_PARAMETERS</a>
<a class="permalink" href="#PriFiProtocol.Received_ALL_CLI_PARAMETERS">¶</a>
</h3>
<pre>func (p *<a href="#PriFiProtocol">PriFiProtocol</a>) Received_ALL_CLI_PARAMETERS(msg <a href="#ALL_ALL_PARAMETERS">ALL_ALL_PARAMETERS</a>) <a href="https://golang.org/pkg/builtin/#error">error</a></pre>
<p>
Received_ALL_CLI_PARAMETERS handles ALL_CLI_PARAMETERS messages.
It uses the message's parameters to initialize the client.
</p>
<h3 id="PriFiProtocol.Received_ALL_CLI_SHUTDOWN">func (*PriFiProtocol) <a href="/src/github.com/lbarman/prifi_dev/prifi-lib/client.go?s=5766:5843#L141">Received_ALL_CLI_SHUTDOWN</a>
<a class="permalink" href="#PriFiProtocol.Received_ALL_CLI_SHUTDOWN">¶</a>
</h3>
<pre>func (p *<a href="#PriFiProtocol">PriFiProtocol</a>) Received_ALL_CLI_SHUTDOWN(msg <a href="#ALL_ALL_SHUTDOWN">ALL_ALL_SHUTDOWN</a>) <a href="https://golang.org/pkg/builtin/#error">error</a></pre>
<p>
Received_ALL_CLI_SHUTDOWN handles ALL_CLI_SHUTDOWN messages.
When we receive this message, we should clean up resources.
</p>
<h3 id="PriFiProtocol.Received_ALL_REL_PARAMETERS">func (*PriFiProtocol) <a href="/src/github.com/lbarman/prifi_dev/prifi-lib/relay.go?s=10590:10671#L261">Received_ALL_REL_PARAMETERS</a>
<a class="permalink" href="#PriFiProtocol.Received_ALL_REL_PARAMETERS">¶</a>
</h3>
<pre>func (p *<a href="#PriFiProtocol">PriFiProtocol</a>) Received_ALL_REL_PARAMETERS(msg <a href="#ALL_ALL_PARAMETERS">ALL_ALL_PARAMETERS</a>) <a href="https://golang.org/pkg/builtin/#error">error</a></pre>
<p>
Received_ALL_REL_PARAMETERS handles ALL_REL_PARAMETERS.
It initializes the relay with the parameters contained in the message.
</p>
<h3 id="PriFiProtocol.Received_ALL_REL_SHUTDOWN">func (*PriFiProtocol) <a href="/src/github.com/lbarman/prifi_dev/prifi-lib/relay.go?s=9297:9374#L219">Received_ALL_REL_SHUTDOWN</a>
<a class="permalink" href="#PriFiProtocol.Received_ALL_REL_SHUTDOWN">¶</a>
</h3>
<pre>func (p *<a href="#PriFiProtocol">PriFiProtocol</a>) Received_ALL_REL_SHUTDOWN(msg <a href="#ALL_ALL_SHUTDOWN">ALL_ALL_SHUTDOWN</a>) <a href="https://golang.org/pkg/builtin/#error">error</a></pre>
<p>
Received_ALL_REL_SHUTDOWN handles ALL_REL_SHUTDOWN messages.
When we receive this message, we should warn other protocol participants and clean resources.
</p>
<h3 id="PriFiProtocol.Received_ALL_TRU_PARAMETERS">func (*PriFiProtocol) <a href="/src/github.com/lbarman/prifi_dev/prifi-lib/trustee.go?s=4443:4524#L124">Received_ALL_TRU_PARAMETERS</a>
<a class="permalink" href="#PriFiProtocol.Received_ALL_TRU_PARAMETERS">¶</a>
</h3>
<pre>func (p *<a href="#PriFiProtocol">PriFiProtocol</a>) Received_ALL_TRU_PARAMETERS(msg <a href="#ALL_ALL_PARAMETERS">ALL_ALL_PARAMETERS</a>) <a href="https://golang.org/pkg/builtin/#error">error</a></pre>
<p>
Received_ALL_REL_PARAMETERS handles ALL_REL_PARAMETERS.
It initializes the trustee with the parameters contained in the message.
</p>
<h3 id="PriFiProtocol.Received_ALL_TRU_SHUTDOWN">func (*PriFiProtocol) <a href="/src/github.com/lbarman/prifi_dev/prifi-lib/trustee.go?s=3978:4055#L109">Received_ALL_TRU_SHUTDOWN</a>
<a class="permalink" href="#PriFiProtocol.Received_ALL_TRU_SHUTDOWN">¶</a>
</h3>
<pre>func (p *<a href="#PriFiProtocol">PriFiProtocol</a>) Received_ALL_TRU_SHUTDOWN(msg <a href="#ALL_ALL_SHUTDOWN">ALL_ALL_SHUTDOWN</a>) <a href="https://golang.org/pkg/builtin/#error">error</a></pre>
<p>
Received_ALL_REL_SHUTDOWN handles ALL_REL_SHUTDOWN messages.
When we receive this message we should  clean up resources.
</p>
<h3 id="PriFiProtocol.Received_CLI_REL_TELL_PK_AND_EPH_PK">func (*PriFiProtocol) <a href="/src/github.com/lbarman/prifi_dev/prifi-lib/relay.go?s=33328:33425#L786">Received_CLI_REL_TELL_PK_AND_EPH_PK</a>
<a class="permalink" href="#PriFiProtocol.Received_CLI_REL_TELL_PK_AND_EPH_PK">¶</a>
</h3>
<pre>func (p *<a href="#PriFiProtocol">PriFiProtocol</a>) Received_CLI_REL_TELL_PK_AND_EPH_PK(msg <a href="#CLI_REL_TELL_PK_AND_EPH_PK">CLI_REL_TELL_PK_AND_EPH_PK</a>) <a href="https://golang.org/pkg/builtin/#error">error</a></pre>
<p>
Received_CLI_REL_TELL_PK_AND_EPH_PK handles CLI_REL_TELL_PK_AND_EPH_PK messages.
Those are sent by the client to tell their identity.
We do nothing until we have collected one per client; then, we pack them in one message
and send them to the first trustee for it to Neff-Shuffle them.
</p>
<h3 id="PriFiProtocol.Received_CLI_REL_UPSTREAM_DATA">func (*PriFiProtocol) <a href="/src/github.com/lbarman/prifi_dev/prifi-lib/relay.go?s=13762:13849#L336">Received_CLI_REL_UPSTREAM_DATA</a>
<a class="permalink" href="#PriFiProtocol.Received_CLI_REL_UPSTREAM_DATA">¶</a>
</h3>
<pre>func (p *<a href="#PriFiProtocol">PriFiProtocol</a>) Received_CLI_REL_UPSTREAM_DATA(msg <a href="#CLI_REL_UPSTREAM_DATA">CLI_REL_UPSTREAM_DATA</a>) <a href="https://golang.org/pkg/builtin/#error">error</a></pre>
<p>
Received_CLI_REL_UPSTREAM_DATA handles CLI_REL_UPSTREAM_DATA messages and is part of PriFi's main loop.
This is what happens in one round, for the relay. We receive some upstream data.
If we have collected data from all entities for this round, we can call DecodeCell() and get the output.
If we get data for another round (in the future) we should buffer it.
If we finished a round (we had collected all data, and called DecodeCell()), we need to finish the round by sending some data down.
Either we send something from the SOCKS/VPN buffer, or we answer the latency-test message if we received any, or we send 1 bit.
</p>
<h3 id="PriFiProtocol.Received_REL_CLI_DOWNSTREAM_DATA">func (*PriFiProtocol) <a href="/src/github.com/lbarman/prifi_dev/prifi-lib/client.go?s=8679:8770#L198">Received_REL_CLI_DOWNSTREAM_DATA</a>
<a class="permalink" href="#PriFiProtocol.Received_REL_CLI_DOWNSTREAM_DATA">¶</a>
</h3>
<pre>func (p *<a href="#PriFiProtocol">PriFiProtocol</a>) Received_REL_CLI_DOWNSTREAM_DATA(msg <a href="#REL_CLI_DOWNSTREAM_DATA">REL_CLI_DOWNSTREAM_DATA</a>) <a href="https://golang.org/pkg/builtin/#error">error</a></pre>
<p>
Received_REL_CLI_DOWNSTREAM_DATA handles REL_CLI_DOWNSTREAM_DATA messages which are part of PriFi's main loop.
This is what happens in one round, for this client. We receive some downstream data.
It should be encrypted, and we should test if this data is for us or not; if so, push it into the SOCKS/VPN chanel.
For now, we do nothing with the downstream data.
Once we received some data from the relay, we need to reply with a DC-net cell (that will get combined with other client's cell to produce some plaintext).
If we're lucky (if this is our slot), we are allowed to embed some message (which will be the output produced by the relay). Either we send something from the
SOCKS/VPN data, or if we're running latency tests, we send a "ping" message to compute the latency. If we have nothing to say, we send 0's.
</p>
<h3 id="PriFiProtocol.Received_REL_CLI_TELL_EPH_PKS_AND_TRUSTEES_SIG">func (*PriFiProtocol) <a href="/src/github.com/lbarman/prifi_dev/prifi-lib/client.go?s=20348:20467#L471">Received_REL_CLI_TELL_EPH_PKS_AND_TRUSTEES_SIG</a>
<a class="permalink" href="#PriFiProtocol.Received_REL_CLI_TELL_EPH_PKS_AND_TRUSTEES_SIG">¶</a>
</h3>
<pre>func (p *<a href="#PriFiProtocol">PriFiProtocol</a>) Received_REL_CLI_TELL_EPH_PKS_AND_TRUSTEES_SIG(msg <a href="#REL_CLI_TELL_EPH_PKS_AND_TRUSTEES_SIG">REL_CLI_TELL_EPH_PKS_AND_TRUSTEES_SIG</a>) <a href="https://golang.org/pkg/builtin/#error">error</a></pre>
<p>
Received_REL_CLI_TELL_EPH_PKS_AND_TRUSTEES_SIG handles REL_CLI_TELL_EPH_PKS_AND_TRUSTEES_SIG messages.
These are sent after the Shuffle protocol has been done by the Trustees and the Relay.
The relay is sending us the result, so we should check that the protocol went well :
1) each trustee announced must have signed the shuffle
2) we need to locate which is our slot &lt;-- THIS IS BUGGY NOW
When this is done, we are ready to communicate !
As the client should send the first data, we do so; to keep this function simple, the first data is blank
(the message has no content / this is a wasted message). The actual embedding of data happens only in the
"round function", that is Received_REL_CLI_DOWNSTREAM_DATA().
</p>
<h3 id="PriFiProtocol.Received_REL_CLI_TELL_TRUSTEES_PK">func (*PriFiProtocol) <a href="/src/github.com/lbarman/prifi_dev/prifi-lib/client.go?s=17704:17797#L407">Received_REL_CLI_TELL_TRUSTEES_PK</a>
<a class="permalink" href="#PriFiProtocol.Received_REL_CLI_TELL_TRUSTEES_PK">¶</a>
</h3>
<pre>func (p *<a href="#PriFiProtocol">PriFiProtocol</a>) Received_REL_CLI_TELL_TRUSTEES_PK(msg <a href="#REL_CLI_TELL_TRUSTEES_PK">REL_CLI_TELL_TRUSTEES_PK</a>) <a href="https://golang.org/pkg/builtin/#error">error</a></pre>
<p>
Received_REL_CLI_TELL_TRUSTEES_PK handles REL_CLI_TELL_TRUSTEES_PK messages. These are sent when we connect.
The relay sends us a pack of public key which correspond to the set of pre-agreed trustees.
Of course, there should be check on those public keys (each client need to trust one), but for now we assume those public keys belong indeed to the trustees,
and that clients have agreed on the set of trustees.
Once we receive this message, we need to reply with our Public Key (Used to derive DC-net secrets), and our Ephemeral Public Key (used for the Shuffle protocol)
</p>
<h3 id="PriFiProtocol.Received_REL_CLI_UDP_DOWNSTREAM_DATA">func (*PriFiProtocol) <a href="/src/github.com/lbarman/prifi_dev/prifi-lib/client.go?s=11137:11232#L245">Received_REL_CLI_UDP_DOWNSTREAM_DATA</a>
<a class="permalink" href="#PriFiProtocol.Received_REL_CLI_UDP_DOWNSTREAM_DATA">¶</a>
</h3>
<pre>func (p *<a href="#PriFiProtocol">PriFiProtocol</a>) Received_REL_CLI_UDP_DOWNSTREAM_DATA(msg <a href="#REL_CLI_DOWNSTREAM_DATA">REL_CLI_DOWNSTREAM_DATA</a>) <a href="https://golang.org/pkg/builtin/#error">error</a></pre>
<p>
Received_REL_CLI_UDP_DOWNSTREAM_DATA handles REL_CLI_UDP_DOWNSTREAM_DATA messages which are part of PriFi's main loop.
This is what happens in one round, for this client.
We receive some downstream data. It should be encrypted, and we should test if this data is for us or not; is so, push it into the SOCKS/VPN chanel.
For now, we do nothing with the downstream data.
Once we received some data from the relay, we need to reply with a DC-net cell (that will get combined with other client's cell to produce some plaintext).
If we're lucky (if this is our slot), we are allowed to embed some message (which will be the output produced by the relay). Either we send something from the
SOCKS/VPN data, or if we're running latency tests, we send a "ping" message to compute the latency. If we have nothing to say, we send 0's.
</p>
<h3 id="PriFiProtocol.Received_REL_TRU_TELL_CLIENTS_PKS_AND_EPH_PKS_AND_BASE">func (*PriFiProtocol) <a href="/src/github.com/lbarman/prifi_dev/prifi-lib/trustee.go?s=9092:9227#L254">Received_REL_TRU_TELL_CLIENTS_PKS_AND_EPH_PKS_AND_BASE</a>
<a class="permalink" href="#PriFiProtocol.Received_REL_TRU_TELL_CLIENTS_PKS_AND_EPH_PKS_AND_BASE">¶</a>
</h3>
<pre>func (p *<a href="#PriFiProtocol">PriFiProtocol</a>) Received_REL_TRU_TELL_CLIENTS_PKS_AND_EPH_PKS_AND_BASE(msg <a href="#REL_TRU_TELL_CLIENTS_PKS_AND_EPH_PKS_AND_BASE">REL_TRU_TELL_CLIENTS_PKS_AND_EPH_PKS_AND_BASE</a>) <a href="https://golang.org/pkg/builtin/#error">error</a></pre>
<p>
Received_REL_TRU_TELL_CLIENTS_PKS_AND_EPH_PKS_AND_BASE handles REL_TRU_TELL_CLIENTS_PKS_AND_EPH_PKS_AND_BASE messages.
Those are sent when the connection to a relay is established.
They contain the long-term and ephemeral public keys of the clients,
and a base given by the relay. In addition to deriving the secrets,
the trustee uses the ephemeral keys to perform a Neff shuffle. It remembers
this shuffle in order to check the correctness of the chain of shuffle afterwards.
</p>
<h3 id="PriFiProtocol.Received_REL_TRU_TELL_RATE_CHANGE">func (*PriFiProtocol) <a href="/src/github.com/lbarman/prifi_dev/prifi-lib/trustee.go?s=7398:7491#L214">Received_REL_TRU_TELL_RATE_CHANGE</a>
<a class="permalink" href="#PriFiProtocol.Received_REL_TRU_TELL_RATE_CHANGE">¶</a>
</h3>
<pre>func (p *<a href="#PriFiProtocol">PriFiProtocol</a>) Received_REL_TRU_TELL_RATE_CHANGE(msg <a href="#REL_TRU_TELL_RATE_CHANGE">REL_TRU_TELL_RATE_CHANGE</a>) <a href="https://golang.org/pkg/builtin/#error">error</a></pre>
<p>
Received_REL_TRU_TELL_RATE_CHANGE handles REL_TRU_TELL_RATE_CHANGE messages
by changing the cipher sending rate.
Either the trustee must stop sending because the relay is at full capacity
or the trustee sends normally because the relay has emptied up enough capacity.
</p>
<h3 id="PriFiProtocol.Received_REL_TRU_TELL_TRANSCRIPT">func (*PriFiProtocol) <a href="/src/github.com/lbarman/prifi_dev/prifi-lib/trustee.go?s=12255:12346#L331">Received_REL_TRU_TELL_TRANSCRIPT</a>
<a class="permalink" href="#PriFiProtocol.Received_REL_TRU_TELL_TRANSCRIPT">¶</a>
</h3>
<pre>func (p *<a href="#PriFiProtocol">PriFiProtocol</a>) Received_REL_TRU_TELL_TRANSCRIPT(msg <a href="#REL_TRU_TELL_TRANSCRIPT">REL_TRU_TELL_TRANSCRIPT</a>) <a href="https://golang.org/pkg/builtin/#error">error</a></pre>
<p>
Received_REL_TRU_TELL_TRANSCRIPT handles REL_TRU_TELL_TRANSCRIPT messages.
Those are sent when all trustees have already shuffled. They need to verify all the shuffles, and also that
their own shuffle has been included in the chain of shuffles. If that's the case, this trustee signs the *last*
shuffle (which will be used by the clients), and sends it back to the relay.
If everything succeed, starts the goroutine for sending DC-net ciphers to the relay.
</p>
<h3 id="PriFiProtocol.Received_TRU_REL_DC_CIPHER">func (*PriFiProtocol) <a href="/src/github.com/lbarman/prifi_dev/prifi-lib/relay.go?s=16932:17011#L413">Received_TRU_REL_DC_CIPHER</a>
<a class="permalink" href="#PriFiProtocol.Received_TRU_REL_DC_CIPHER">¶</a>
</h3>
<pre>func (p *<a href="#PriFiProtocol">PriFiProtocol</a>) Received_TRU_REL_DC_CIPHER(msg <a href="#TRU_REL_DC_CIPHER">TRU_REL_DC_CIPHER</a>) <a href="https://golang.org/pkg/builtin/#error">error</a></pre>
<p>
Received_TRU_REL_DC_CIPHER handles TRU_REL_DC_CIPHER messages. Those contain a DC-net cipher from a Trustee.
If it's for this round, we call decode on it, and remember we received it.
If for a future round we need to Buffer it.
</p>
<h3 id="PriFiProtocol.Received_TRU_REL_SHUFFLE_SIG">func (*PriFiProtocol) <a href="/src/github.com/lbarman/prifi_dev/prifi-lib/relay.go?s=41448:41531#L976">Received_TRU_REL_SHUFFLE_SIG</a>
<a class="permalink" href="#PriFiProtocol.Received_TRU_REL_SHUFFLE_SIG">¶</a>
</h3>
<pre>func (p *<a href="#PriFiProtocol">PriFiProtocol</a>) Received_TRU_REL_SHUFFLE_SIG(msg <a href="#TRU_REL_SHUFFLE_SIG">TRU_REL_SHUFFLE_SIG</a>) <a href="https://golang.org/pkg/builtin/#error">error</a></pre>
<p>
Received_TRU_REL_SHUFFLE_SIG handles TRU_REL_SHUFFLE_SIG messages.
Those contain the signature from the NeffShuffleS-transcript from one trustee.
We do nothing until we have all signatures; when we do, we pack those
in one message with the result of the Neff-Shuffle and send them to the clients.
When this is done, we are finally ready to communicate. We wait for the client's messages.
</p>
<h3 id="PriFiProtocol.Received_TRU_REL_TELL_NEW_BASE_AND_EPH_PKS">func (*PriFiProtocol) <a href="/src/github.com/lbarman/prifi_dev/prifi-lib/relay.go?s=36782:36893#L868">Received_TRU_REL_TELL_NEW_BASE_AND_EPH_PKS</a>
<a class="permalink" href="#PriFiProtocol.Received_TRU_REL_TELL_NEW_BASE_AND_EPH_PKS">¶</a>
</h3>
<pre>func (p *<a href="#PriFiProtocol">PriFiProtocol</a>) Received_TRU_REL_TELL_NEW_BASE_AND_EPH_PKS(msg <a href="#TRU_REL_TELL_NEW_BASE_AND_EPH_PKS">TRU_REL_TELL_NEW_BASE_AND_EPH_PKS</a>) <a href="https://golang.org/pkg/builtin/#error">error</a></pre>
<p>
Received_TRU_REL_TELL_NEW_BASE_AND_EPH_PKS handles TRU_REL_TELL_NEW_BASE_AND_EPH_PKS messages.
Those are sent by the trustees once they finished a Neff-Shuffle.
In that case, we forward the result to the next trustee.
We do nothing until the last trustee sends us this message.
When this happens, we pack a transcript, and broadcast it to all the trustees who will sign it.
</p>
<h3 id="PriFiProtocol.Received_TRU_REL_TELL_PK">func (*PriFiProtocol) <a href="/src/github.com/lbarman/prifi_dev/prifi-lib/relay.go?s=30763:30838#L723">Received_TRU_REL_TELL_PK</a>
<a class="permalink" href="#PriFiProtocol.Received_TRU_REL_TELL_PK">¶</a>
</h3>
<pre>func (p *<a href="#PriFiProtocol">PriFiProtocol</a>) Received_TRU_REL_TELL_PK(msg <a href="#TRU_REL_TELL_PK">TRU_REL_TELL_PK</a>) <a href="https://golang.org/pkg/builtin/#error">error</a></pre>
<p>
Received_TRU_REL_TELL_PK handles TRU_REL_TELL_PK messages. Those are sent by the trustees message when we connect them.
We do nothing, until we have received one per trustee; Then, we pack them in one message, and broadcast it to the clients.
</p>
<h3 id="PriFiProtocol.SendUpstreamData">func (*PriFiProtocol) <a href="/src/github.com/lbarman/prifi_dev/prifi-lib/client.go?s=14647:14695#L332">SendUpstreamData</a>
<a class="permalink" href="#PriFiProtocol.SendUpstreamData">¶</a>
</h3>
<pre>func (p *<a href="#PriFiProtocol">PriFiProtocol</a>) SendUpstreamData() <a href="https://golang.org/pkg/builtin/#error">error</a></pre>
<p>
SendUpstreamData determines if it's our round, embeds data (maybe latency-test message) in the payload if we can,
creates the DC-net cipher and sends it to the relay.
</p>
<h3 id="PriFiProtocol.Send_TRU_REL_DC_CIPHER">func (*PriFiProtocol) <a href="/src/github.com/lbarman/prifi_dev/prifi-lib/trustee.go?s=6290:6357#L174">Send_TRU_REL_DC_CIPHER</a>
<a class="permalink" href="#PriFiProtocol.Send_TRU_REL_DC_CIPHER">¶</a>
</h3>
<pre>func (p *<a href="#PriFiProtocol">PriFiProtocol</a>) Send_TRU_REL_DC_CIPHER(rateChan chan <a href="https://golang.org/pkg/builtin/#int16">int16</a>)</pre>
<p>
Send_TRU_REL_DC_CIPHER sends DC-net ciphers to the relay continuously once started.
One can control the rate by sending flags to "rateChan".
</p>
<h3 id="PriFiProtocol.Send_TRU_REL_PK">func (*PriFiProtocol) <a href="/src/github.com/lbarman/prifi_dev/prifi-lib/trustee.go?s=5706:5753#L155">Send_TRU_REL_PK</a>
<a class="permalink" href="#PriFiProtocol.Send_TRU_REL_PK">¶</a>
</h3>
<pre>func (p *<a href="#PriFiProtocol">PriFiProtocol</a>) Send_TRU_REL_PK() <a href="https://golang.org/pkg/builtin/#error">error</a></pre>
<p>
Send_TRU_REL_PK tells the relay's public key to the relay
(this, of course, provides no security, but this is an early version of the protocol).
This is the first action of the trustee.
</p>
<h3 id="PriFiProtocol.WhoAmI">func (*PriFiProtocol) <a href="/src/github.com/lbarman/prifi_dev/prifi-lib/prifi.go?s=5114:5150#L140">WhoAmI</a>
<a class="permalink" href="#PriFiProtocol.WhoAmI">¶</a>
</h3>
<pre>func (prifi *<a href="#PriFiProtocol">PriFiProtocol</a>) WhoAmI()</pre>
<p>
WhoAmI prints a description of the state of the PriFi entity
on which it is called.
</p>
<h2 id="REL_CLI_DOWNSTREAM_DATA">type <a href="/src/github.com/lbarman/prifi_dev/prifi-lib/messages.go?s=2024:2117#L69">REL_CLI_DOWNSTREAM_DATA</a>
<a class="permalink" href="#REL_CLI_DOWNSTREAM_DATA">¶</a>
</h2>
<pre>type REL_CLI_DOWNSTREAM_DATA struct {
    RoundId    <a href="https://golang.org/pkg/builtin/#int32">int32</a>
    Data       []<a href="https://golang.org/pkg/builtin/#byte">byte</a>
    FlagResync <a href="https://golang.org/pkg/builtin/#bool">bool</a>
}</pre>
<p>
REL_CLI_DOWNSTREAM_DATA message contains the downstream data for a client for a given round
and is sent by the relay to the clients.
</p>
<h2 id="REL_CLI_DOWNSTREAM_DATA_UDP">type <a href="/src/github.com/lbarman/prifi_dev/prifi-lib/messages.go?s=4834:4922#L145">REL_CLI_DOWNSTREAM_DATA_UDP</a>
<a class="permalink" href="#REL_CLI_DOWNSTREAM_DATA_UDP">¶</a>
</h2>
<pre>type REL_CLI_DOWNSTREAM_DATA_UDP struct {
    <a href="#REL_CLI_DOWNSTREAM_DATA">REL_CLI_DOWNSTREAM_DATA</a>
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
<p>
REL_CLI_DOWNSTREAM_DATA_UDP message is a bit special. It's a REL_CLI_DOWNSTREAM_DATA, simply named with _UDP postfix to be able to distinguish them from type,
and theoretically that should be it. But since it doesn't go through SDA (which does not support UDP yet), we have to manually convert it to bytes.
For that purpose, this message implements MarshallableMessage, defined in prifi-sda-wrapper/udp.go.
Hence, it has methods Print(), used for debug, ToBytes(), that converts it to a raw byte array, SetByte(), which simply store a byte array in the
structure (but does not decode it), and FromBytes(), which decodes the REL_CLI_DOWNSTREAM_DATA from the inner buffer set by SetBytes()
</p>
<h3 id="REL_CLI_DOWNSTREAM_DATA_UDP.FromBytes">func (*REL_CLI_DOWNSTREAM_DATA_UDP) <a href="/src/github.com/lbarman/prifi_dev/prifi-lib/messages.go?s=5919:5989#L181">FromBytes</a>
<a class="permalink" href="#REL_CLI_DOWNSTREAM_DATA_UDP.FromBytes">¶</a>
</h3>
<pre>func (m *<a href="#REL_CLI_DOWNSTREAM_DATA_UDP">REL_CLI_DOWNSTREAM_DATA_UDP</a>) FromBytes() (interface{}, <a href="https://golang.org/pkg/builtin/#error">error</a>)</pre>
<p>
FromBytes decodes the message contained in the message's byteEncoded field.
</p>
<h3 id="REL_CLI_DOWNSTREAM_DATA_UDP.Print">func (REL_CLI_DOWNSTREAM_DATA_UDP) <a href="/src/github.com/lbarman/prifi_dev/prifi-lib/messages.go?s=4971:5015#L151">Print</a>
<a class="permalink" href="#REL_CLI_DOWNSTREAM_DATA_UDP.Print">¶</a>
</h3>
<pre>func (m <a href="#REL_CLI_DOWNSTREAM_DATA_UDP">REL_CLI_DOWNSTREAM_DATA_UDP</a>) Print()</pre>
<p>
Print prints the raw value of this message.
</p>
<h3 id="REL_CLI_DOWNSTREAM_DATA_UDP.SetBytes">func (*REL_CLI_DOWNSTREAM_DATA_UDP) <a href="/src/github.com/lbarman/prifi_dev/prifi-lib/messages.go?s=5099:5158#L156">SetBytes</a>
<a class="permalink" href="#REL_CLI_DOWNSTREAM_DATA_UDP.SetBytes">¶</a>
</h3>
<pre>func (m *<a href="#REL_CLI_DOWNSTREAM_DATA_UDP">REL_CLI_DOWNSTREAM_DATA_UDP</a>) SetBytes(data []<a href="https://golang.org/pkg/builtin/#byte">byte</a>)</pre>
<p>
SetBytes sets the bytes contained in this message.
</p>
<h3 id="REL_CLI_DOWNSTREAM_DATA_UDP.ToBytes">func (*REL_CLI_DOWNSTREAM_DATA_UDP) <a href="/src/github.com/lbarman/prifi_dev/prifi-lib/messages.go?s=5284:5347#L162">ToBytes</a>
<a class="permalink" href="#REL_CLI_DOWNSTREAM_DATA_UDP.ToBytes">¶</a>
</h3>
<pre>func (m *<a href="#REL_CLI_DOWNSTREAM_DATA_UDP">REL_CLI_DOWNSTREAM_DATA_UDP</a>) ToBytes() ([]<a href="https://golang.org/pkg/builtin/#byte">byte</a>, <a href="https://golang.org/pkg/builtin/#error">error</a>)</pre>
<p>
ToBytes encodes a message into a slice of bytes.
</p>
<h2 id="REL_CLI_TELL_EPH_PKS_AND_TRUSTEES_SIG">type <a href="/src/github.com/lbarman/prifi_dev/prifi-lib/messages.go?s=2281:2417#L77">REL_CLI_TELL_EPH_PKS_AND_TRUSTEES_SIG</a>
<a class="permalink" href="#REL_CLI_TELL_EPH_PKS_AND_TRUSTEES_SIG">¶</a>
</h2>
<pre>type REL_CLI_TELL_EPH_PKS_AND_TRUSTEES_SIG struct {
    Base         <a href="../../../../github.com/dedis/crypto/abstract/index.html">abstract</a>.<a href="../../../../github.com/dedis/crypto/abstract/index.html#Point">Point</a>
    EphPks       []<a href="../../../../github.com/dedis/crypto/abstract/index.html">abstract</a>.<a href="../../../../github.com/dedis/crypto/abstract/index.html#Point">Point</a>
    TrusteesSigs [][]<a href="https://golang.org/pkg/builtin/#byte">byte</a>
}</pre>
<p>
REL_CLI_TELL_EPH_PKS_AND_TRUSTEES_SIG message contains the ephemeral public keys and the signatures
of the trustees and is sent by the relay to the client.
</p>
<h2 id="REL_CLI_TELL_TRUSTEES_PK">type <a href="/src/github.com/lbarman/prifi_dev/prifi-lib/messages.go?s=2540:2602#L85">REL_CLI_TELL_TRUSTEES_PK</a>
<a class="permalink" href="#REL_CLI_TELL_TRUSTEES_PK">¶</a>
</h2>
<pre>type REL_CLI_TELL_TRUSTEES_PK struct {
    Pks []<a href="../../../../github.com/dedis/crypto/abstract/index.html">abstract</a>.<a href="../../../../github.com/dedis/crypto/abstract/index.html#Point">Point</a>
}</pre>
<p>
REL_CLI_TELL_TRUSTEES_PK message contains the public keys of the trustees
and is sent by the relay to the clients.
</p>
<h2 id="REL_TRU_TELL_CLIENTS_PKS_AND_EPH_PKS_AND_BASE">type <a href="/src/github.com/lbarman/prifi_dev/prifi-lib/messages.go?s=2765:2899#L91">REL_TRU_TELL_CLIENTS_PKS_AND_EPH_PKS_AND_BASE</a>
<a class="permalink" href="#REL_TRU_TELL_CLIENTS_PKS_AND_EPH_PKS_AND_BASE">¶</a>
</h2>
<pre>type REL_TRU_TELL_CLIENTS_PKS_AND_EPH_PKS_AND_BASE struct {
    Pks    []<a href="../../../../github.com/dedis/crypto/abstract/index.html">abstract</a>.<a href="../../../../github.com/dedis/crypto/abstract/index.html#Point">Point</a>
    EphPks []<a href="../../../../github.com/dedis/crypto/abstract/index.html">abstract</a>.<a href="../../../../github.com/dedis/crypto/abstract/index.html#Point">Point</a>
    Base   <a href="../../../../github.com/dedis/crypto/abstract/index.html">abstract</a>.<a href="../../../../github.com/dedis/crypto/abstract/index.html#Point">Point</a>
}</pre>
<p>
REL_TRU_TELL_CLIENTS_PKS_AND_EPH_PKS_AND_BASE message contains the public keys and ephemeral keys
of the clients and is sent by the relay to the trustees.
</p>
<h2 id="REL_TRU_TELL_RATE_CHANGE">type <a href="/src/github.com/lbarman/prifi_dev/prifi-lib/messages.go?s=3673:3733#L120">REL_TRU_TELL_RATE_CHANGE</a>
<a class="permalink" href="#REL_TRU_TELL_RATE_CHANGE">¶</a>
</h2>
<pre>type REL_TRU_TELL_RATE_CHANGE struct {
    WindowCapacity <a href="https://golang.org/pkg/builtin/#int">int</a>
}</pre>
<p>
REL_TRU_TELL_RATE_CHANGE message asks the trustees to update their window capacity to adapt their
sending rate and is sent by the relay.
</p>
<h2 id="REL_TRU_TELL_TRANSCRIPT">type <a href="/src/github.com/lbarman/prifi_dev/prifi-lib/messages.go?s=3057:3165#L99">REL_TRU_TELL_TRANSCRIPT</a>
<a class="permalink" href="#REL_TRU_TELL_TRANSCRIPT">¶</a>
</h2>
<pre>type REL_TRU_TELL_TRANSCRIPT struct {
    G_s    []<a href="../../../../github.com/dedis/crypto/abstract/index.html">abstract</a>.<a href="../../../../github.com/dedis/crypto/abstract/index.html#Point">Point</a>
    EphPks [][]<a href="../../../../github.com/dedis/crypto/abstract/index.html">abstract</a>.<a href="../../../../github.com/dedis/crypto/abstract/index.html#Point">Point</a>
    Proofs [][]<a href="https://golang.org/pkg/builtin/#byte">byte</a>
}</pre>
<p>
REL_TRU_TELL_TRANSCRIPT message contains all the shuffles perfomrmed in a Neff shuffle round.
It is sent by the relay to the trustees to be verified.
</p>
<h2 id="RelayState">type <a href="/src/github.com/lbarman/prifi_dev/prifi-lib/relay.go?s=5991:7354#L135">RelayState</a>
<a class="permalink" href="#RelayState">¶</a>
</h2>
<pre>type RelayState struct {
    CellCoder <a href="../../../../github.com/lbarman/prifi_dev/prifi-lib/dcnet/index.html">dcnet</a>.<a href="../../../../github.com/lbarman/prifi_dev/prifi-lib/dcnet/index.html#CellCoder">CellCoder</a>

    DataForClients         chan []<a href="https://golang.org/pkg/builtin/#byte">byte</a> <span class="comment">// VPN / SOCKS should put data there !</span>
    PriorityDataForClients chan []<a href="https://golang.org/pkg/builtin/#byte">byte</a>
    DataFromDCNet          chan []<a href="https://golang.org/pkg/builtin/#byte">byte</a> <span class="comment">// VPN / SOCKS should read data from there !</span>
    DataOutputEnabled      <a href="https://golang.org/pkg/builtin/#bool">bool</a>        <span class="comment">// If FALSE, nothing will be written to DataFromDCNet</span>
    DownstreamCellSize     <a href="https://golang.org/pkg/builtin/#int">int</a>
    MessageHistory         <a href="../../../../github.com/dedis/crypto/abstract/index.html">abstract</a>.<a href="../../../../github.com/dedis/crypto/abstract/index.html#Cipher">Cipher</a>
    Name                   <a href="https://golang.org/pkg/builtin/#string">string</a>

    PublicKey            <a href="../../../../github.com/dedis/crypto/abstract/index.html">abstract</a>.<a href="../../../../github.com/dedis/crypto/abstract/index.html#Point">Point</a>
    ExperimentRoundLimit <a href="https://golang.org/pkg/builtin/#int">int</a>

    UpstreamCellSize        <a href="https://golang.org/pkg/builtin/#int">int</a>
    UseDummyDataDown        <a href="https://golang.org/pkg/builtin/#bool">bool</a>
    UseUDP                  <a href="https://golang.org/pkg/builtin/#bool">bool</a>
    WindowSize              <a href="https://golang.org/pkg/builtin/#int">int</a>
    ExperimentResultChannel chan interface{}
    ExperimentResultData    interface{}
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
<p>
RelayState contains the mutable state of the relay.
</p>
<h3 id="NewRelayState">func <a href="/src/github.com/lbarman/prifi_dev/prifi-lib/relay.go?s=7453:7699#L176">NewRelayState</a>
<a class="permalink" href="#NewRelayState">¶</a>
</h3>
<pre>func NewRelayState(nTrustees <a href="https://golang.org/pkg/builtin/#int">int</a>, nClients <a href="https://golang.org/pkg/builtin/#int">int</a>, upstreamCellSize <a href="https://golang.org/pkg/builtin/#int">int</a>, downstreamCellSize <a href="https://golang.org/pkg/builtin/#int">int</a>, windowSize <a href="https://golang.org/pkg/builtin/#int">int</a>, useDummyDataDown <a href="https://golang.org/pkg/builtin/#bool">bool</a>, experimentRoundLimit <a href="https://golang.org/pkg/builtin/#int">int</a>, experimentResultChan chan interface{}, useUDP <a href="https://golang.org/pkg/builtin/#bool">bool</a>, dataOutputEnabled <a href="https://golang.org/pkg/builtin/#bool">bool</a>) *<a href="#RelayState">RelayState</a></pre>
<p>
NewRelayState initializes the state of this relay.
It must be called before anything else.
</p>
<h2 id="TRU_REL_DC_CIPHER">type <a href="/src/github.com/lbarman/prifi_dev/prifi-lib/messages.go?s=3280:3363#L106">TRU_REL_DC_CIPHER</a>
<a class="permalink" href="#TRU_REL_DC_CIPHER">¶</a>
</h2>
<pre>type TRU_REL_DC_CIPHER struct {
    RoundId   <a href="https://golang.org/pkg/builtin/#int32">int32</a>
    TrusteeId <a href="https://golang.org/pkg/builtin/#int">int</a>
    Data      []<a href="https://golang.org/pkg/builtin/#byte">byte</a>
}</pre>
<p>
TRU_REL_DC_CIPHER message contains the DC-net cipher of a trustee for a given round and is sent to the relay.
</p>
<h2 id="TRU_REL_SHUFFLE_SIG">type <a href="/src/github.com/lbarman/prifi_dev/prifi-lib/messages.go?s=3460:3528#L113">TRU_REL_SHUFFLE_SIG</a>
<a class="permalink" href="#TRU_REL_SHUFFLE_SIG">¶</a>
</h2>
<pre>type TRU_REL_SHUFFLE_SIG struct {
    TrusteeId <a href="https://golang.org/pkg/builtin/#int">int</a>
    Sig       []<a href="https://golang.org/pkg/builtin/#byte">byte</a>
}</pre>
<p>
TRU_REL_SHUFFLE_SIG contains the signatures shuffled by a trustee and is sent to the relay.
</p>
<h2 id="TRU_REL_TELL_NEW_BASE_AND_EPH_PKS">type <a href="/src/github.com/lbarman/prifi_dev/prifi-lib/messages.go?s=3853:3974#L126">TRU_REL_TELL_NEW_BASE_AND_EPH_PKS</a>
<a class="permalink" href="#TRU_REL_TELL_NEW_BASE_AND_EPH_PKS">¶</a>
</h2>
<pre>type TRU_REL_TELL_NEW_BASE_AND_EPH_PKS struct {
    NewBase   <a href="../../../../github.com/dedis/crypto/abstract/index.html">abstract</a>.<a href="../../../../github.com/dedis/crypto/abstract/index.html#Point">Point</a>
    NewEphPks []<a href="../../../../github.com/dedis/crypto/abstract/index.html">abstract</a>.<a href="../../../../github.com/dedis/crypto/abstract/index.html#Point">Point</a>
    Proof     []<a href="https://golang.org/pkg/builtin/#byte">byte</a>
}</pre>
<p>
TRU_REL_TELL_NEW_BASE_AND_EPH_PKS message contains the new ephemeral key of a trustee and
is sent to the relay.
</p>
<h2 id="TRU_REL_TELL_PK">type <a href="/src/github.com/lbarman/prifi_dev/prifi-lib/messages.go?s=4066:4138#L133">TRU_REL_TELL_PK</a>
<a class="permalink" href="#TRU_REL_TELL_PK">¶</a>
</h2>
<pre>type TRU_REL_TELL_PK struct {
    TrusteeId <a href="https://golang.org/pkg/builtin/#int">int</a>
    Pk        <a href="../../../../github.com/dedis/crypto/abstract/index.html">abstract</a>.<a href="../../../../github.com/dedis/crypto/abstract/index.html#Point">Point</a>
}</pre>
<p>
TRU_REL_TELL_PK message contains the public key of a trustee and is sent to the relay.
</p>
<h2 id="TrusteeState">type <a href="/src/github.com/lbarman/prifi_dev/prifi-lib/trustee.go?s=2016:2518#L44">TrusteeState</a>
<a class="permalink" href="#TrusteeState">¶</a>
</h2>
<pre>type TrusteeState struct {
    CellCoder        <a href="../../../../github.com/lbarman/prifi_dev/prifi-lib/dcnet/index.html">dcnet</a>.<a href="../../../../github.com/lbarman/prifi_dev/prifi-lib/dcnet/index.html#CellCoder">CellCoder</a>
    ClientPublicKeys []<a href="../../../../github.com/dedis/crypto/abstract/index.html">abstract</a>.<a href="../../../../github.com/dedis/crypto/abstract/index.html#Point">Point</a>

    Id             <a href="https://golang.org/pkg/builtin/#int">int</a>
    MessageHistory <a href="../../../../github.com/dedis/crypto/abstract/index.html">abstract</a>.<a href="../../../../github.com/dedis/crypto/abstract/index.html#Cipher">Cipher</a>
    Name           <a href="https://golang.org/pkg/builtin/#string">string</a>

    PayloadLength <a href="https://golang.org/pkg/builtin/#int">int</a>

    PublicKey <a href="../../../../github.com/dedis/crypto/abstract/index.html">abstract</a>.<a href="../../../../github.com/dedis/crypto/abstract/index.html#Point">Point</a>

    TrusteeId <a href="https://golang.org/pkg/builtin/#int">int</a>
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
<p>
TrusteeState contains the mutable state of the trustee.
</p>
<h3 id="NewTrusteeState">func <a href="/src/github.com/lbarman/prifi_dev/prifi-lib/trustee.go?s=2847:2944#L74">NewTrusteeState</a>
<a class="permalink" href="#NewTrusteeState">¶</a>
</h3>
<pre>func NewTrusteeState(trusteeId <a href="https://golang.org/pkg/builtin/#int">int</a>, nClients <a href="https://golang.org/pkg/builtin/#int">int</a>, nTrustees <a href="https://golang.org/pkg/builtin/#int">int</a>, payloadLength <a href="https://golang.org/pkg/builtin/#int">int</a>) *<a href="#TrusteeState">TrusteeState</a></pre>
<p>
NewTrusteeState initializes the state of the trustee.
It must be called before anything else.
</p>
<h2 id="pkg-subdirectories">Subdirectories</h2>
<div class="pkg-dir">
<table>
<tr>
<th class="pkg-name">Name</th>
<th class="pkg-synopsis">Synopsis</th>
</tr>
<tr>
<td colspan="2"><a href="..">..</a></td>
</tr>
<tr>
<td class="pkg-name" style="padding-left: 0px;">
<a href="auth/index.html">auth</a>
</td>
<td class="pkg-synopsis">
							Package auth contain PriFi's main authentication mechanisms
						</td>
</tr>
<tr>
<td class="pkg-name" style="padding-left: 20px;">
<a href="auth/basic/index.html">basic</a>
</td>
<td class="pkg-synopsis">
							Package basicAuth implements a basic public-public key authentication mechanism similar to SSH authentication protocol
						</td>
</tr>
<tr>
<td class="pkg-name" style="padding-left: 20px;">
<a href="auth/daga/index.html">daga</a>
</td>
<td class="pkg-synopsis">
							Package daga implements the Deniable Anonymous Group Authentication (DAGA) protocol
						</td>
</tr>
<tr>
<td class="pkg-name" style="padding-left: 0px;">
<a href="config/index.html">config</a>
</td>
<td class="pkg-synopsis">
							Package config contains the cryptographic primitives that are used by the PriFi library.
						</td>
</tr>
<tr>
<td class="pkg-name" style="padding-left: 0px;">
<a href="crypto/index.html">crypto</a>
</td>
<td class="pkg-synopsis">
							Package crypto contains the implementations of the cryptographic primitives used by the PriFi library.
						</td>
</tr>
<tr>
<td class="pkg-name" style="padding-left: 0px;">
<a href="dcnet/index.html">dcnet</a>
</td>
<td class="pkg-synopsis">
							Package dcnet provides an abstract interface for Dining Cryptographers (DC-nets) anonymous coding schemes, as well as implementations of multiple specific DC-nets coding schemes.
						</td>
</tr>
<tr>
<td class="pkg-name" style="padding-left: 0px;">
<a href="scheduler.deprecated/index.html">scheduler.deprecated</a>
</td>
<td class="pkg-synopsis">
</td>
</tr>
</table>
</div>

</div><!-- .container -->
</div><!-- #page -->
<!-- TODO(adonovan): load these from <head> using "defer" attribute? -->
<script src="../../../../.goduckstyle/jquery.js" type="text/javascript"></script>
<script src="../../../../.goduckstyle/jquery.treeview.js" type="text/javascript"></script>
<script src="../../../../.goduckstyle/jquery.treeview.edit.js" type="text/javascript"></script>
<script>var goVersion = "go1.7.1";</script>
<script src="../../../../.goduckstyle/godocs.js" type="text/javascript"></script>
</body>
</html>
